# 数据结构

## 算法概念

### 算法的五个基本特征：

+ 有穷性：执行有穷步后结束
+ 确定性：只有一条执行路径
+ 可行性：每一步都可行
+ 输入：具有零个或多个输入
+ 输出：具有一个或多个输出

### 算法设计的要求

+ 正确性
+ 可读性
+ 健壮性
+ 时间效率高和存储量低

## 时间复杂度

### 简单的时间复杂度度量

```C
int main(){
	int i,j,n = 100;
	for(i=0;i<n;i++){
		for(j=i;j<n;j++){
			printf("11")；
		}
	}
}//执行次数为：n+(n-1)+(n-2)+...+1  = n(n+1)/2 = n^2/2+n/2
//时间复杂度为O(n^2)
```

### 函数调用的时间复杂度度量

```c
void function(int count){
	int j,n=100;
    for(j=count;j<n;j++){
        printf("%d",j);
    }
}
int main(){
    int i,j,n=100;
    for(i=0;i<n;i++){
        function(i);
    }//O(n^2)
    for(i=0;i<n;i++){
        for(j=i;j<n;j++){
            printf("%d",j);
        }
    }//O(n^2)
}//时间复杂度O(n^2)
```

### 常见的时间复杂度

| 时间复杂度 |  术语   |
| :--------: | :-----: |
|    O(1)    | 常数阶  |
|    O(n)    | 线性阶  |
|  O(n^2^)   | 平方阶  |
|  O(logn)   | 对数阶  |
|  O(nlogn)  | nlogn阶 |
|  O(n^3^)   | 立方阶  |
|  O(2^n^)   | 指数阶  |

### 复杂度比较

O(1)<O(logn)<O(n)<O(nlogn)<O(n^2^)<O(n^3^)<O(2^n^)<O(n!)<O(n^n^)

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209061539274.png" alt="在这里插入图片描述" style="zoom: 67%;" />

## 线性表

有零个或多个数据元素组成的有限序列

### 数据类型

定义：指一组性质相同的值的集合及定义在此集合上的一些操作的总称

+ 原子类型：不可再分解的基本类型，例如整型、浮点型、字符型等
+ 结构类型：由若干个类型组合而成，是可以再分解的，例如整形数组是由若干个整型数据组成的

抽象数据类型：指一个数学模型及其定义在该模型上的一组操作

### 线性表的抽象数据类型

ADT 线性表（list)

Data 集合{a1,a2,a3，...} 数据类型为ElemType

Operation

​	InitList(*L):初始化操作，建立一个空的线性表L

​	ListEmpty(L):判断线性表是否为空表

​	Clearlist(*L):清空线性表

​	GetElem(L,i,*e):将线性表第i个元素值返回给e

​	LocateElem(L,e):在线性表中查找e，成功返回序号

​	ListInsert(*L,i,e):在线性表第i个元素之前插入e

​	ListDelete(*L,i,\*e):删除线性表中第i个位置元素，并用e返回其值

​	ListLength(L):返回线性表L的元素个数

### 线性表的物理存储结构

+ 顺序存储结构

+ 链式存储结构

## 线性表顺序存储结构

### 线性表（Sequence List)

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 100

//定义线性表
typedef int ElemType;
typedef struct{
    ElemType data[MAXSIZE] ;
    int length;
}SqList;

//初始化线性表
void InitList(SqList *L){
    int i;
    for(i=1;i<5;i++){
        L->data[i-1] = i;
    }

    L->length = 4;
}

//GetElem(L,i,*e):将线性表第i个元素值返回给e
bool GetElem(SqList L, int i, ElemType *e){
    if(i<1 || i > L.length || L.length == 0){
        return false;
    }
    *e = L.data[i-1];
    return true;
}

//ListInsert(*L,i,e):在线性表第i个元素之前插入e
bool ListInsert(SqList *L, int i, ElemType e){
    int k;
    if(L->length == MAXSIZE||i<1 || i>L->length ){
        return false;
    }else if(i<=L->length){
        for(k=L->length-1;k>=i-1;k--){
            L->data[k+1] = L->data[k];
        }
    }
    L->data[i-1] = e;
    L->length ++;
}

//ListDelete(*L,i,\*e):删除线性表中第i个位置元素，并用e返回其值
bool ListDelete(SqList *L, int i, ElemType *e){
    int k;
    if(i<1 || i > L->length || L->length == 0){
        return false;
    }
    *e = L->data[i-1];
    if(i<L->length){
        for(k=i;k<L->length;k++){
            L->data[k-1]=L->data[k];
        }
    }
    L->length --;
}

//LocateElem(L,e):在线性表中查找e，成功返回序号
int LocateElem(SqList *L,ElemType e){
    int i;
    for(i=0;i<L->length;i++){
        if(L->data[i] == e){
            return i+1;
        }
    }
    printf("查找不到");
}

//清空线性表
void ClearList(SqList *L){
    L->length = 0;
}

//打印线性表
void PrintList(SqList *L){
    int i;
    for(i=0;i<L->length;i++){
        printf("%d\t",L->data[i]);
    }
    printf("\n");
}

int main(){
    SqList *L = (SqList *)malloc(sizeof(SqList));
    int *e = (int *)malloc(sizeof(int));
  
    InitList(L);
    PrintList(L);
    GetElem(*L,2,e);
    printf("%d\n",*e);
    ListInsert(L,2,5);
    PrintList(L);
    ListDelete(L,2,e);
    PrintList(L);
    printf("%d\n",LocateElem(L,2));
    ClearList(L);
    PrintList(L);
    return 0;
}
```

###  时间复杂度（优缺点）

优点：存入、读取数据时：O(1)

+ 无须为表示表中元素之间的逻辑关系而增加额外的存储空间。
+ 可以快速地存取表中任意位置的元素。

缺点：插入、删除数据时：O(n)

+ 插入和删除操作需要移动大里元素。
+ 当线性表长度变化较大时,难以确定存储空间容量。
+ 容易造成存储空间的“碎片”。

## 线性表链式存储结构

### 单链表(Single Linklist)

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct Node{
    int value;
    struct Node *next;
}node;

//头插法创建新的链表
void CreatListHead(node *L,int n){
    node *p;
    int i ;
    srand(time(0));  //初始化随机数种子

    for(i=0;i<n;i++){
        p = (node*)malloc(sizeof(node));
        p->value = rand()%100+1;    //1~100
        p->next = L->next;
        L->next = p;
    }
}

//尾插法创建新的链表
void CreatListTail(node *L,int n){
    node *p,*r;
    int i;
    srand(time(0));
    r = L;     //r指向当前结点

    for(i=0;i<n;i++){
        p = (node*)malloc(sizeof(node));
        p->next = NULL;
        p->next = NULL;
        p->value = rand()%100+1;
        r->next = p;
        r = p;
    }
}

//GetElem(L,i,*e):将线性表第i个元素值返回给e
bool GetElem(node* L,int i,int *e){
    int j = 1;
    node *p = L->next;
    while(p && j<i ){
        p = p->next;
        ++j;
    }
    if(!p || j>i){
        printf("查找不到");
        return false;
    }
    *e = p->value;
    return true;
}

//ListInsert(*L,i,e):在线性表第i个元素之前插入e
bool ListInsert(node* L,int i,int e){
    node *p = L ;
    int j = 1;
    while( p && j<i){
        p  = p->next;
        j++;
    }
    if(!p || j>i){
        return false;
    }
    node *s = (node*)malloc(sizeof(node));
    s->value = e;
    s->next = p->next ;
    p->next = s;
    return true;
}

//ListDelete(*L,i,*e):删除线性表中第i个位置元素，并用e返回其值
bool ListDelete(node *L,int i,int *e){
    int j = 1;
    node *p = L;
    while(p && j<i){
        p = p->next;
        j++;
    }
//    if(!(p->next) || j>i){
//        return false;
//    }
    node *q = p->next;
    p->next = q->next;
    *e = q->value;
    free(q);
    return true;
}

//LocateElem(L,e):在线性表中查找e，成功返回序号
int LocateElem(node *L,int e){
    node *p = L->next;
    int cot = 1;
    while(p){
        if(p->value == e){
            return cot;
        }
        cot++;
        p = p->next;
    }
    printf("查找不到");
    return 0;
}

//Clearlist(*L):清空线性表
bool ClearList(node *L){
    node *p = L->next;
    node *q;
    while(p){
        q = p->next;
        free(p);
        p = q;
    }
    L->next = NULL;
    return true;
}

//打印线性表
void PrintList(node *L){
    node *p = L->next;
    while(p){
        printf("%d\t",p->value);
        p = p->next;
    }
    printf("\n");
}

int main(){
    node *L =(node*)malloc(sizeof(node));
    L->next = NULL;
    int *e =(int*) malloc(sizeof(int));

    CreatListTail(L,5);
    PrintList(L);
    CreatListHead(L,5);
    PrintList(L);
    ListInsert(L,1,520);
    PrintList(L);
    GetElem(L,1,e);
    printf("%d\n",*e);
    printf("%d\n",LocateElem(L,520));
    ListDelete(L,1,e);
    PrintList(L);
    ClearList(L);
    return 0;
}
```

### 快慢指针找中间结点

```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

typedef int ElemType;
typedef struct Node{
    ElemType data;
    struct Node *next;
}node;

void CreatListTail(node *L,int n){
    node *p,*r = L;
    srand(time(0));
    int i;

    for(i=0;i<n;i++){
        p = (node*)malloc(sizeof(node));
        p->next = NULL;
        p->data = rand()%100 +1;
        r->next = p;
        r = p;
    }
    printf("创建成功\n");
}

void ListView(node *L){
    node *p = L->next;
    while(p){
        printf("%d\t",p->data);
        p = p->next;
    }
    printf("\n");
}

void ListClear(node *L){
    node *p = L;
    node *q = L->next;
    while(p){
        p = q->next;
        free(q);
        q = p;
    }
    L->next = NULL;
    printf("清空完成\n");
}

void GetMidNode(node *L,ElemType *e){
    node *search,*mid;
    search = mid = L;
    while (search->next !=NULL){
        if(search->next->next != NULL){
            search = search->next->next;
            mid = mid->next;
        } else{
            mid = mid->next;
            search = search->next;
        }
    }
    *e = mid->data;
}


void showmenu(){
    printf("1.创建链表\n");
    printf("2.查看链表\n");
    printf("3.中间结点\n");
    printf("4.清空链表\n");
    printf("0.退出\n");
    printf("-------------\n");
}

int main(){
    node *L = (node*)malloc(sizeof(node));
    L->next = NULL;
    int select = 1;
    int n = 0;
    int *e =(int *) malloc(sizeof(int));
    showmenu();
    while(true){
        printf("请输入序号:");
        scanf("%d",&select);
        switch (select) {
            case 1 :
                printf("输入链表的长度：");
                scanf("%d",&n);
                CreatListTail(L,n);
                break;
            case 2:
                ListView(L);
                break;
            case 3:
                GetMidNode(L,e);
                printf("中间结点为：%d\n",*e);
                break;
            case 4:
                ListClear(L);
                break;
            case 0 :
                free(e);
                return 0;
        }
    }

}
```



### 静态链表(Static Linklist)

#### 静态链表的插入

| 游标 |  5   |  2   |  3   |  4   |  0   |  6   |  7   | ...  |  1   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数据 |      |  A   |  C   |  D   |  E   |      |      | ...  |      |
| 下标 |  0   |  1   |  2   |  3   |  4   |  5   |  6   | ...  | 999  |

在第二个元素C前面插入B之后

| 游标 | ==6== | ==5== |  3   |  4   |  0   | ==2== |  7   | ...  |  1   |
| :--: | :---: | :---: | :--: | :--: | :--: | :---: | :--: | :--: | :--: |
| 数据 |       |   A   |  C   |  D   |  E   | ==B== |      | ...  |      |
| 下标 |   0   |   1   |  2   |  3   |  4   |   5   |  6   | ...  | 999  |

#### 静态链表的删除

| 游标 |  6   |  5   |  3   |  4   |  0   |  2   |  7   | ...  |  1   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数据 |      |  A   |  C   |  D   |  E   |  B   |      | ...  |      |
| 下标 |  0   |  1   |  2   |  3   |  4   |  5   |  6   | ...  | 999  |

删除第二个元素C之后

| 游标 | ==2== |  5   | ==6== |  4   |  0   | ==3== |  7   | ...  |  1   |
| :--: | :---: | :--: | :---: | :--: | :--: | :---: | :--: | :--: | :--: |
| 数据 |       |  A   |       |  D   |  E   |   B   |      | ...  |      |
| 下标 |   0   |  1   |   2   |  3   |  4   |   5   |  6   | ...  | 999  |

#### 静态链表的实现

```c
#include <stdio.h>
#define MAXSIZE 10

typedef struct Component{
    char data;
    int cur;
}StaticLinkList[MAXSIZE];

//初始化数组的游标
bool InitList(StaticLinkList space){
    int i;
    for(i=0;i<MAXSIZE-1;i++){
        space[i].cur = i + 1;
    }
    space[MAXSIZE-1].cur = 1;
    return true;
}

//获取空闲分量的下标
int Malloc_SLL(StaticLinkList space){
    int i = space[0].cur;
    if(space[0].cur){
        space[0].cur = space[i].cur;   //把它的下一个分量用来备用
    }
    return i;
}

//获取L的长度
int ListLength(StaticLinkList L){
    int Length = 0;
    int i = L[MAXSIZE-1].cur;
    while(i){
        i = L[i].cur;
        Length++;
    }
    return Length;
}

//在L的第i个元素之前插入e
bool ListInsert(StaticLinkList L,int i,char e){
    int j,k,l;
    k = MAXSIZE-1;
    if(i<1 || i>ListLength(L)+1){
        return false;
    }

    j = Malloc_SLL(L);  //j为新插入元素的下标

    if(j){
        L[j].data = e;
        for(l=1;l<=i-1;l++){
            k = L[k].cur; //k为第i-1个元素的下标
        }
        L[j].cur = L[k].cur; //将新插入元素的游标指向第i个元素
        L[k].cur = j;  //将第i-1个元素的游标指向新插入的元素
    }
    return true;
}

//将下标为k的空闲结点回收到备用链表
void Free_SLL(StaticLinkList space,int k){
    space[k].cur = space[0].cur;
    space[0].cur = k;
}

//删除L的第i个元素
bool ListDelete(StaticLinkList L,int i){
    int j,k;

    if(i<1 || i>ListLength(L)){
        return false;
    }

    k = MAXSIZE - 1;

    for(j=1; j<i;j++){
        k = L[k].cur;   //k为第i-1个元素的下标
    }
    j = L[k].cur;       //j为第i个元素的下标
    L[k].cur = L[j].cur;  //将第i-1个元素的游标指向第i+1个元素

    Free_SLL(L,j);
    return true;
}

void PrintList(StaticLinkList L){
    int i = L[MAXSIZE-1].cur;
    while(i){
        printf("%c\t",L[i].data);
        i = L[i].cur;
    }
    printf("\n");
}

int main(){
    StaticLinkList L;
    InitList(L);

    L[1].data ='A';
    L[2].data ='C';
    L[3].data ='D';
    L[4].data ='E';
    L[4].cur = 0;
    L[0].cur = 5;

    PrintList(L);
    ListInsert(L,2,'B');
    PrintList(L);
    ListDelete(L,3);
    PrintList(L);
}
```

###  循环链表(Double Linklist)

<img src="https://gitee.com/newcwc/picture/raw/master/image/202207272228967.png" alt="image-20220727222812977" style="zoom:33%;" />

#### 实现代码(有头结点)

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef int ElemType;
typedef struct Node{
    ElemType data;
    struct Node *next;
}node;

typedef struct List{
    node *head;
    node *tail;
    int length;
}list;

void CLinkListInit(List *L){
    node *head = (node*)malloc(sizeof(node));
    L->head = L->tail = head;
    L->length = 0;
    head->next = head;
}

node* GetElem(list *L,int i){
    if(i == 0) return L->head;
    if(L->length < i||i<1) {
        printf("错误");
    }
    node *p = L->head->next;
    while (i > 1){
        p = p->next;
        i--;
    }
    return p;
}

int LocateElem(List *L,ElemType e){
    node *p = L->head->next;
    for(int i=1;i<L->length;i++){
        if(p->data == e) return i;
        p = p->next;
    }
    return NULL;
}

bool IfEmpty(List *L){
    return (L->head->next == L->head);
}

void ListInsertHead(list *L,ElemType e){
    node *p = (node*) malloc(sizeof(node));
    p->data = e;
    p->next = L->head->next;
    L->head->next = p;
    if(L->head == L->tail){
        L->tail = p ;
    }
    L->length++;
}

void ListInsertTail(list *L,ElemType e){
    node *p = (node*) malloc(sizeof(node));
    p->data = e;

    p->next = L->head;
    L->tail->next = p;
    L->tail = p;
    L->length++;
}

//按位插入
bool ListLocalInsert(list *L,int i,ElemType e){
    if(i>L->length+1||i<1) return false;
    if(IfEmpty(L)) return false;
    node *p = GetElem(L,i-1);
    node *newNode = (node*) malloc(sizeof (node));
    newNode->data = e;
    newNode->next = p->next;
    p->next = newNode;
    L->length ++;
    return true;
}

bool ListDelete(list *L,int i){
    if(i>L->length||i<1) return false;
    if(IfEmpty(L)) return false;
    node *p = GetElem(L,i-1);
    node *q = p->next;
    p->next = q->next;
    free(q);
    L->length --;
    return true;
}

bool ListClear(list *L){
    if(IfEmpty(L)) return false;
    node *p = L->head->next;
    node *q = L->head->next;
    for(int i=1;i<=L->length;i++){
         p = p->next;
         free(q);
         q = p;
    }
    L->head->next = L->head;
    L->length = 0;
    return true;
}

void PrintList(list *L){
    if(IfEmpty(L)) printf("空表");
    node *p = L->head->next;
    for(int i=1;i<=L->length;i++){
        printf("%d\t",p->data);
        p = p->next;
    }
    printf("\n");
}

int main(){
    list *L = (list*) malloc(sizeof (list));
    CLinkListInit(L);
    srand(time(0));

    for(int i=0;i<5;i++){
        ListInsertHead(L,rand()%100+1);
    }
    PrintList(L);
    for(int i=0;i<5;i++){
        ListInsertHead(L,rand()%100+1);
    }
    PrintList(L);
    ListLocalInsert(L,2,520);
    PrintList(L);
    printf("%d\n", LocateElem(L,520));
    ListDelete(L,1);
    PrintList(L);
    ListClear(L);
}
```

#### 约瑟夫问题(无头结点)

41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int data;
    struct Node *next;
}node;

typedef struct List{
    node *head;
    node *tail;
    int length;
}list;

void ListInit(list *L){
    node *head = (node*)malloc(sizeof(node));
    L->head = L->tail = head;
    L->head->data = NULL;
    head ->next =head;
    L->length = 0;
}

void ListInsertTail(list *L,int e){
   if(L->head->data == NULL){
       L->head->data = e;
   }else{
   node *p = (node*)malloc(sizeof(node));
   p->data = e;
   p->next = L->head;
   L->tail->next = p;
   L->tail = p;
   }
   L->length++;
}

void PrintList(list *L){
    node *p = L->head;
    for(int i=1;i<=L->length;i++){
        printf("%d\t",p->data);
        p = p->next;
    }
    printf("\n");
}


int main(){
    List *L = (list*) malloc(sizeof (list));
    ListInit(L);

    int n = 41;
    int m = 3;

    for(int i=1;i<=n;i++){
        ListInsertTail(L,i);
    }
    PrintList(L);
    node *temp;
    node *p = L->head;

    while( p != p->next){
        for(int i=1;i<m-1;i++){
            p = p->next;
        }
        printf("%d->",p->next->data);
        temp = p->next;
        p->next = temp->next;
        free(temp);
        p = p->next;
        L->length --;
    }
    printf("%d",p->data);
    free(p);
    return 0;
}
```

#### 判断单链表是否成环

<img src="https://gitee.com/newcwc/picture/raw/master/image/202207281145326.png" alt="image-20220728114549516" style="zoom: 50%;" />

**第一种方法:**

使用p、q两个指针，p总是向前走，但q总是从头开始走，若p与q步数不等，则存在环

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int data;
    struct Node *next;
}node;

typedef struct List{
    node *head;
    node *tail;
    int length;
}list;

void ListInit(list *L){
    node *head = (node*)malloc(sizeof (node));
    L->head = L->tail = head;
    L->head->next = head;
    L->length = 0;
}

void ListInsertTail(list *L,int e){
    node *p = (node*)malloc(sizeof (node));
    p->data = e;
    p->next = L->head;
    L->tail->next = p;
    L->tail = p;
    L->length ++;
}

void ListPrint(list *L){
    node *p = L->head->next;
    for(int i=1;i<=L->length;i++){
        printf("%d\t",p->data);
        p = p->next;
    }
}

void ListClear(list *L){
    node *p = L->head;
    node *q = L->head;
    for(int i=1;i<=L->length;i++){
        p = p->next;
        free(q);
        q = p;
    }
}

int main(){
    list *L = (list*) malloc(sizeof (list));
    ListInit(L);

    for(int i=2;i<7;i++){
        ListInsertTail(L,i);
    }
    L->tail->next = L->head->next->next;
    //L->tail->next = NULL;
    L->length++;

    ListPrint(L);

    node *p = L->head;
    int pnum = 0;
    int qnum = 0;

    while(pnum == qnum & qnum <L->length & p->next!= NULL){
        qnum = 0;
        p = p->next;
        pnum ++;
        node *q = L->head;
        while(p != q){
            q = q->next;
            qnum ++;
        }
    }

    if(pnum == qnum){
        printf("该链表无环");}
    else{
        printf("环在第%d个结点",qnum);
    }

    ListClear(L);
    return 0;
}
```

**第二种方法（快慢指针）**

使用p、q两个指针，p每次向前走一步，q每次向前走两步，若在每个时候 p=q,则存在环

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int data;
    struct Node *next;
}node;

typedef struct List{
    node *head;
    node *tail;
    int length;
}list;

void ListInit(list *L){
    node *head = (node*)malloc(sizeof (node));
    L->head = L->tail = head;
    L->head->next = head;
    L->length = 0;
}

void ListInsertTail(list *L,int e){
    node *p = (node*)malloc(sizeof (node));
    p->data = e;
    p->next = L->head;
    L->tail->next = p;
    L->tail = p;
    L->length ++;
}

void ListPrint(list *L){
    node *p = L->head->next;
    for(int i=1;i<=L->length;i++){
        printf("%d\t",p->data);
        p = p->next;
    }
}

void ListClear(list *L){
    node *p = L->head;
    node *q = L->head;
    for(int i=1;i<=L->length;i++){
        p = p->next;
        free(q);
        q = p;
    }
}

int main(){
    list *L = (list*) malloc(sizeof (list));
    ListInit(L);

    for(int i=2;i<7;i++){
        ListInsertTail(L,i);
    }
	L->head->data = 1;
	L->tail->next = L->head->next->next;
    ListPrint(L);

    node *p = L->head;
    node *q = L->head;

    while(p != NULL && q!= NULL){
        p = p->next;
        if(q->next ==NULL || q->next->next ==NULL){
            printf("无");
            break;
        }
        q = q->next->next;
        if(q == p){
            printf("此链表有环");
            break;
        } 
    }

    ListClear(L);
    return 0;
}
```

#### 魔术师问题

- 魔术师口中数1，将第一张牌翻过来看正好是A；魔术师将黑桃A放到桌上，继续数手里的余牌。
- 魔术师第二次数1，2，将第1张牌放到这叠牌的下面，将第2张牌翻开，正好是黑桃2，也把它放在桌子上。
- 魔术师第三次数1，2，3，前面2张牌放到这叠牌的下面，取出第3张牌，正好是黑桃3，这样依次将13张牌翻出，全部都准确无误。

牌的顺序：

<img src="https://gitee.com/newcwc/picture/raw/master/image/202207291439399.png" alt="image-20220729111741311" style="zoom: 67%;" />

代码实现：

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int data;
    struct Node *next;
}node;

typedef struct List{
    node *head;
    node *tail;
    int length;
}list;

void ListInit(list *L){
    node *head = (node*)malloc(sizeof(node));
    L->head = L->tail = head;
    L->head->data = NULL;
    head ->next =head;
    L->length = 1;
}

void ListInsertTail(list *L,int e){

        node *p = (node*)malloc(sizeof(node));
        p->data = e;
        p->next = L->head;
        L->tail->next = p;
        L->tail = p;

    L->length++;
}

void PrintList(list *L){
    node *p = L->head;
    for(int i=1;i<=L->length;i++){
        printf("%d\t",p->data);
        p = p->next;
    }
    printf("\n");
}

int main(){
    List *L = (list*) malloc(sizeof (list));
    ListInit(L);
    L->head->data = 1;

    for(int i=1;i<13;i++){
        ListInsertTail(L,0);
    }
    PrintList(L);

    int cot = 2;

    node *p = L->head;

    while(cot<14) {
        for (int i = 0; i < cot; i++) {
            p = p->next;
            if (p->data != 0) {
                i--;
            }
        }
        p->data = cot;
        cot++;
    }

    PrintList(L);
    return 0;
}
```

### 双向链表

<center>
    <img src="https://gitee.com/newcwc/picture/raw/master/image/202207291118401.png" alt="image-20220729111741311" style="zoom: 54%;" />
    <img src="https://gitee.com/newcwc/picture/raw/master/image/202207291118733.png" alt="image-20220729111827647" style="zoom:46%;" />
</center>
#### 双向链表的插入

<img src="https://gitee.com/newcwc/picture/raw/master/image/202207292046569.png" alt="image-20220729191309054" style="zoom: 50%;" />

#### 双向链表的删除

<img src="https://gitee.com/newcwc/picture/raw/master/image/202207292046588.png" alt="image-20220729191445295" style="zoom:50%;" />

#### 代码实现

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int data;
    struct Node *next;
    struct Node *prior;
}node;

typedef struct List{
    node *head;
    node *tail;
    int length;
}list;

void ListInit(list *L){
    node *head = (node*) malloc(sizeof (node));
    L->head = L->tail = head;
    head->next = head->prior = head;
    L->length = 0;
}

void ListInsertTail(list *L,int e){
    node *p = (node*) malloc(sizeof (node));
    p->data = e;
    p->next = L->head;
    p->prior = L->tail;
    L->head->prior = p;
    L->tail->next = p;
    L->tail = p;
    L->length ++;
}

void ListDelete(list *L,int i){
    node *p = L->head;
    for(int j=0;j<i;j++){
        p = p->next;
    }
    p->prior->next = p->next;
    p->next->prior = p->prior;
    free(p);
    L->length --;
}

void ListInsert(list *L,int i,int e){
    node *p = L->head;
    node *q = (node*) malloc(sizeof (node));
    q->data = e;
    for(int j=1;j<i;j++){
        p = p->next;
    }
    q->next = p->next;
    q->prior = p;
    p->next->prior = q;
    p->next = q;
    L->length ++;
}

void PrintList(list *L){
    node *p = L->head;
    for(int i=0;i<L->length;i++){
        p = p->next;
        printf("%d\t",p->data);
    }
    printf("\n");
}

int main(){
    list *L = (list*) malloc(sizeof (list));
    ListInit(L);
    for(int i=1;i<10;i++){
        ListInsertTail(L,i);
    }
    PrintList(L);
    ListDelete(L,2);
    PrintList(L);
    ListInsert(L,2,2);
    PrintList(L);
    return 0;
}
```

#### 字母调序

要求实现用户输入一个数使得26个字母的排列发生变化，例如用户输入3，输出结果:DEFGHIJKLMNOPQRSTUVWXYZABC

同时需要支持负数，例如用户输入-3，输出结果:XYZABCDEFGHIJKLMNOPQRSTUVW

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    char data;
    struct Node *next;
    struct Node *prior;
}node;

typedef struct List{
    node *head;
    node *tail;
    int length;
}list;

void ListInit(list *L){
    node *head = (node*) malloc(sizeof (node));
    L->head = L->tail = head;
    head->next = head->prior = head;
    L->length = 0;
}

void ListInsertTail(list *L,char e){
    node *p = (node*) malloc(sizeof (node));
    p->data = e;
    p->next = L->head;
    p->prior = L->tail;
    L->head->prior = p;
    L->tail->next = p;
    L->tail = p;
    L->length ++;
}

void PrintList(list *L){
    node *p = L->head;
    for(int i=0;i<L->length;i++){
        printf("%c",p->data);
        p = p->next;
    }
    printf("\n");
}

int main(){
    list *L = (list*) malloc(sizeof (list));
    ListInit(L);
    L->head->data = 'A';
    L->length ++;
    for(int i=1;i<26;i++){
        ListInsertTail(L,'A'+i);
    }
    PrintList(L);

    int i;
    printf("请输入一个整数");
    scanf("%d",&i);

    if(i>0){
        do{
            L->head = L->head->next;
        } while (--i);
        PrintList(L);
    }else if(i<0){
        do{
            L->head = L->head->prior;
        } while (++i);
        PrintList(L);
    }else if(i==0){
        PrintList(L);
    }
    system("pause");
    return 0;
}
```

#### Vigenere（维吉尼亚）加密

原理：当输入明文，自动生成随机密匙匹配明文中每个字母并移位加密。例如：

|   明文   |  I   |  L   |  O   |  V   |  E   |  F   |  I   |  S   |  H   |  C   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 随机密匙 |  3   |  15  |  23  |  2   |  52  |  1   |  33  |  49  |  13  |  19  |
|   密文   |  L   |  A   |  L   |  X   |  E   |  G   |  P   |  P   |  U   |  V   |

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define OK 1
#define ERROR 0

typedef char ElemType;
typedef char Status;

typedef struct DualNode
{
    ElemType data;
    ElemType key;
    struct DualNode *prior;
    struct DualNode *next;
}DualNode,*DuLinklist;

Status InitList(DuLinklist *L){
    DualNode *p_temp,*q;
    char ch_temp;
    int i,num=0;
    srand((unsigned)time(NULL));//随机生成数

    *L=(DualNode*)malloc(sizeof(DualNode));
    (*L)->next=(*L)->prior = NULL;//头结点，为空
    p_temp = (*L);
    printf("请输入需要加密的明文，按#键结束：\n");
    scanf("%c",&ch_temp);

    while(ch_temp!='#'){
        q=(DualNode*)malloc(sizeof(DualNode));
        if(!q){
            return ERROR;
        }
        if(ch_temp<'A'||ch_temp>'z'||(ch_temp>'Z'&&ch_temp<'a')){
            q->data=ch_temp;
            q->key=' ';//空格时，不作处理，秘钥为空格
        }else{
            q->data=ch_temp;
            q->key=rand()%50;//随机产出秘钥key
        }

        q->prior = p_temp;
        q->next = p_temp->next;
        p_temp->next = q;
        p_temp = q;
        num=num+1;//计算链表结点数

        scanf("%c",&ch_temp);
    }
    getchar();

    p_temp->next = (*L)->next;
    (*L)->next->prior = p_temp;

    printf("原文为：");//打印原文
    for(i=0;i<num;i++){
        printf("%c",(*L)->next->data);
        (*L)=(*L)->next;
    }
    printf("\n秘钥为：");//打印秘钥
    for(i=0;i<num;i++){
        if((*L)->next->key!=' '){
            printf("%-3d",(*L)->next->key);//秘钥以数字显示
        }
        (*L)=(*L)->next;
    }
    printf("\n");
    return num;
}

void keyword(DuLinklist L,int num)//生成并打印密文
{
    int i,temp;

    printf("密文为：");

    for(i=0;i<num;i++){
        temp = L->next->data + L->next->key%26;
        if(L->next->data>='A' && L->next->data<='Z'){
            if(temp>90){
                L->next->data = temp-26;//'A'+(temp-'Z')-1
            }else{
                L->next->data = temp;//
            }
        }
        if(L->next->data>='a'&&L->next->data<='z'){
            if(temp>122){
                L->next->data=temp-26;//'a'+(temp-'z')-1
            }else{
                L->next->data=temp;//
            }
        }
        printf("%c",L->next->data);
        L = L->next;
    }
    printf("\n");
}

//解密,按秘钥左移
void decrypt(DuLinklist L,int num){
    int i,temp;
    printf("解密为：");
    for(i=0;i<num;i++){
        temp=L->next->data-L->next->key%26;
        if(L->next->data>='A'&&L->next->data<='Z'){
            if(temp<65){
                L->next->data=temp+26;//'A'+(temp-'Z')-1
            }else{
                L->next->data=temp;//
            }
        }
        if(L->next->data>='a'&&L->next->data<='z'){
            if(temp<97){
                L->next->data=temp+26;//'a'+(temp-'z')-1
            }else{
                L->next->data=temp;//
            }
        }
        printf("%c",L->next->data);
        L=L->next;
    }
    printf("\n");
}

int main(){
    DuLinklist L;
    int num,temp;
    num = InitList(&L);
    keyword(L,num);
    decrypt(L,num);
    system("pause");
    return 0;
}
```

## 栈和队列

### 栈(Stack)

#### 定义

栈(Stack）是一个**后进先出(Last in first out,LIFO)**的线性表，它要求只在**表尾**进行删除和插入操作。表的末端为栈顶(Top),表头为栈尾(Bottom)

<img src="https://gitee.com/newcwc/picture/raw/master/image/202207311246328.png" alt="image-20220731124623291" style="zoom:50%;" />

#### 栈的存储结构

+ 顺序存储结构
+ 链式存储结构

### 栈的顺序存储结构

#### 顺序栈的实现

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXSTACK 100
#define ERROR 0
#define OK 1

typedef int Status;

typedef char ElemType;
typedef struct SqStack{
    ElemType *base;
    ElemType *top;
    int stacksize;
}SqStack;

Status InitStack(SqStack *S){
    S->base = (ElemType*) malloc(sizeof (ElemType)*MAXSTACK);
    if(!(S->base)) return ERROR;
    S->top = S->base;
    S->stacksize = MAXSTACK;
    return OK;
}

Status Push(SqStack *S,ElemType e){
    if(S->top - S->base == S->stacksize) return ERROR;
    *(S->top++) = e;
    return OK;
}

Status Pop(SqStack *S,ElemType *e){
    if(S->base == S->top) return ERROR;
    *e = *(--(S->top));
    return OK;
}

Status IsEmpty(SqStack *S){
    if(S->top == S->base) return OK;
    else return ERROR;
}
/*
void ClearStack(SqStack *S){
    S->top = S->base;
}*/

void DestroyStack(SqStack *S){
    for(int i=0;i<S->stacksize;i++){
        free(S->base);
        S->base ++;
    }
    S->base = S->top = NULL;
    S->stacksize = 0;
}

int main(){
    SqStack S;
    InitStack(&S);
    Push(&S,'A');
    Push(&S,'B');
    ElemType e;
    Pop(&S,&e);
    printf("%c",e);
    DestroyStack(&S);
    // ClearStack(&S);
    system("pause");
    return 0;
}
```

#### 二进制转十进制

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAXSTACK 100
#define ERROR 0
#define OK 1

typedef int Status;

typedef char ElemType;
typedef struct SqStack{
    ElemType *base;
    ElemType *top;
    int stacksize;
}SqStack;

Status InitStack(SqStack *S){
    S->base = (ElemType*) malloc(sizeof (ElemType)*MAXSTACK);
    if(!(S->base)) return ERROR;
    S->top = S->base;
    S->stacksize = MAXSTACK;
    return OK;
}

Status Push(SqStack *S,ElemType e){
    if(S->top - S->base == S->stacksize) return ERROR;
    *(S->top++) = e;
    return OK;
}

Status Pop(SqStack *S,ElemType *e){
    if(S->base == S->top) return ERROR;
    *e = *(--(S->top));
    return OK;
}

int StackLen(SqStack *S){
    return (S->top - S->base);
}

void DestroyStack(SqStack *S){
    for(int i=0;i<StackLen(S);i++){
        free(S->base);
        S->base ++;
    }
    S->base = S->top = NULL;
    S->stacksize = 0;
}

int main(){
    ElemType c;
    SqStack S;
    InitStack(&S);

    int sum = 0;
    printf("请输入二进制数，输入#结束\n");
    scanf("%c",&c);
    while (c != '#'){
        Push(&S,c);
        scanf("%c",&c);
    }
    getchar();
    int len = StackLen(&S);
    for(int i=0;i<len;i++){
        Pop(&S,&c);
        sum = sum + (c-48) * pow(2,i);
    }
    printf("转化为十进制为：%d\n",sum);

    DestroyStack(&S);
    system("pause");
    return 0;
}
```

### 栈的链式存储结构(链栈)

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAXSTACK 100
#define ERROR 0
#define OK 1

typedef int Status;
typedef int ElemType;
typedef struct StackNode{
    ElemType data;
    struct StackNode *next;
}StackNode,*LinkStack;

Status InitStack(LinkStack *S){
    *S = NULL;
    return OK;
}

Status Push(LinkStack *S,ElemType e){
    LinkStack pnew = (LinkStack) malloc(sizeof (StackNode));
    pnew->data = e;
    pnew->next = *S;
    *S = pnew;
    return OK;
}

Status Pop(LinkStack *S,ElemType *e){
    LinkStack p = *S;
    *e = p->data;
    *S = p->next;
    free(p);
    return OK;
}

int main(){
    LinkStack S;
    InitStack(&S);
    Push(&S,1);
    Push(&S,2);
    int e;
    Pop(&S,&e);
    printf("%d",e);
    system("pause");
    return 0;
}
```

### 栈的运用

#### 逆波兰表达式

例如：(1 + 2)*3 / 2 = 的逆波兰表达式为：1 2 + 3 * 2 /

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define MAXSTACK 100
#define TEMP 10
#define ERROR 0
#define OK 1

typedef int Status;
typedef double ElemType;
typedef struct SqStack{
    ElemType *base;
    ElemType *top;
    int Stacksize;
}SqStack;

Status InitStack(SqStack *S){
    S->base = (ElemType*) malloc(sizeof (ElemType)*MAXSTACK);
    S->top = S->base;
    S->Stacksize = MAXSTACK;
    return OK;
}

Status Push(SqStack *S,ElemType e){
    if(S->top - S->base == S->Stacksize) return ERROR;
    *(S->top++) = e;
    return OK;
}

Status Pop(SqStack *S,ElemType *e){
    if(S->top == S->base) return ERROR;
    *e = *(--(S->top));
    return OK;
}

int main(){
    char c;
    char str[TEMP];
    int i = 0;
    double d,e;

    SqStack S;
    InitStack(&S);
    printf("请输入逆波兰表达式,中间用空格隔开,以#为结束:\n");

    scanf("%c",&c);
    while(c!='#'){
        while(isdigit(c) || c == '.'){
            str[i++] = c;
            str[i] = '\0';
            if(i>=TEMP){
                printf("输入的数据过大，退出\n");
                system("pause");
                return ERROR;
            }
            scanf("%c",&c);
            if(c == ' '){
               d = atof(str);
               Push(&S,d);
               i = 0;
               break;
            }
        }
        switch (c) {
            case '+':
                Pop(&S,&e);
                Pop(&S,&d);
                Push(&S,d+e);
                break;
            case '-':
                Pop(&S,&e);
                Pop(&S,&d);
                Push(&S,d-e);
                break;
            case '*':
                Pop(&S,&e);
                Pop(&S,&d);
                Push(&S,d*e);
                break;
            case '/':
                Pop(&S,&e);
                Pop(&S,&d);
                if(e == 0){
                    printf("除数为0，错误");
                    system("pause");
                    return ERROR;
                } else{
                    Push(&S,d/e);
                }
                break;
        }
        scanf("%c",&c);
    }
    Pop(&S,&d);
    printf("计算结果为%f\n",d);
    system("pause");
    return 0;
}
```

#### 中缀表达式转为后缀表达式并计算结果

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define MAXSTACK 100
#define TEMP 10
#define ERROR 0
#define OK 1

typedef int Status;
typedef char ElemType;
typedef double ElemType1;

typedef struct SqStack{
    ElemType *base;
    ElemType *top;
    int Stacksize;
}SqStack;

Status InitStack(SqStack *S){
    S->base = (ElemType*) malloc(sizeof (ElemType)*MAXSTACK);
    S->top = S->base;
    S->Stacksize = MAXSTACK;
    return OK;
}

Status Push(SqStack *S,ElemType e){
    if(S->top - S->base == S->Stacksize) return ERROR;
    *(S->top++) = e;
    return OK;
}

Status Pop(SqStack *S,ElemType *e){
    if(S->top == S->base) return ERROR;
    *e = *(--(S->top));
    return OK;
}

typedef struct SqStack1{
    ElemType1 *base;
    ElemType1 *top;
    int Stacksize;
}SqStack1;

Status InitStack(SqStack1 *S){
    S->base = (ElemType1*) malloc(sizeof (ElemType1)*MAXSTACK);
    S->top = S->base;
    S->Stacksize = MAXSTACK;
    return OK;
}

Status Push(SqStack1 *S,ElemType1 e){
    if(S->top - S->base == S->Stacksize) return ERROR;
    *(S->top++) = e;
    return OK;
}

Status Pop(SqStack1 *S,ElemType1 *e){
    if(S->top == S->base) return ERROR;
    *e = *(--(S->top));
    return OK;
}

int StackLen(SqStack *S){
    return (S->top - S->base);
}

Status DestroyStack(SqStack *S){
    free(S->base);
    S->base = NULL;
    S->top = NULL;
    return OK;
}

Status DestroyStack(SqStack1 *S){
    free(S->base);
    S->base = NULL;
    S->top = NULL;
    return OK;
}

Status Switch(SqStack1 *S,char c){
    double e,d;
    switch (c) {
        case '+':
            Pop(S,&e);
            Pop(S,&d);
            Push(S,d+e);
            break;
        case '-':
            Pop(S,&e);
            Pop(S,&d);
            Push(S,d-e);
            break;
        case '*':
            Pop(S,&e);
            Pop(S,&d);
            Push(S,d*e);
            break;
        case '/':
            Pop(S,&e);
            Pop(S,&d);
            if(e == 0){
                printf("除数为0，错误");
                system("pause");
                return ERROR;
            } else{
                Push(S,d/e);
            }
            break;
        default:
            printf("错误");
            return ERROR;
            break;
    }
    return OK;
}
Status change(SqStack *S,SqStack1 *number){
    char c,e;
    char str[TEMP];
    int i = 0;
    double d;

    printf("请输入中缀表达式,以#为结束:");

    scanf("%c",&c);
    printf("转为后缀表达式为:");
    while(c != '#'){
        while((c >='0' && c<='9') || c=='.'){
            str[i++] = c;
            str[i] = '\0';
            if(i>=10){
                printf("数字过长,退出");
                system("pause");
                return 0;
            }
            printf("%c",c);
            scanf("%c",&c);
            if((c<'0' || c>'9') && (c != '.')){
                printf(" ");
                d = atof(str);
                Push(number,d);
                i = 0;
            }
        }

        if(')' == c){
            Pop(S,&e);
            while('(' != e){
                Switch(number,e);
                printf("%c ",e);
                Pop(S,&e);
            }
        }else if('+' == c || '-' == c){
            if(!StackLen(S)){
                Push(S,c);
            }else{
                do{
                    Pop(S,&e);
                    if('(' == e || '+'== e || '-'==e) {
                        Push(S,e);
                        break;
                    }else {
                        Switch(number,e);
                        printf("%c ",e);
                    }
                }while(StackLen(S) && '(' != e);
                Push(S,c);
            }
        }else if('(' == c){
            Push(S,c);
        }else if('*' == c || '/' == c){
            if(!StackLen(S)){
                Push(S,c);
            }else {
                Pop(S, &e);
                if (e == '*' || e == '/') {
                    Switch(number, e);
                    printf("%c ", e);
                    Push(S, c);
                } else {
                    Push(S, e);
                    Push(S, c);
                }
            }
        }
        else if('#' == c){
            break;
        }else{
            printf("输入有误");
        }
        scanf("%c",&c);
    }
    while (StackLen(S)){
        Pop(S,&e);
        Switch(number,e);
        printf("%c ",e);
    }
}


int main(){
    double d;
    SqStack S;
    InitStack(&S);
    SqStack1 number;
    InitStack(&number);

    change(&S,&number);

    Pop(&number,&d);
    printf("\n计算结果为:%f\n",d);

    DestroyStack(&S);
    DestroyStack(&number);
    system("pause");
    return 0;
}
```

运行结果例子：

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208031916017.png" alt="image-20220803191543349" style="zoom: 67%;" />

### 队列

定义：队列（queue）是只允许在一端进行插入操作,而在另一端进行删除操作的线性表。与栈相反,队列是一种先进先出（First In First Out, FIFO)的线性表。

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208021609852.png" alt="image-20220802160905920" style="zoom:50%;" />

### 队列的链式存储结构(链队列)

```c
#include <stdio.h>
#include <stdlib.h>

typedef char ElemType;
typedef struct QueueNode{
    ElemType data;
    struct QueueNode *next;
}QueueNode;

typedef struct LinkQueue{
    QueueNode *front;
    QueueNode *rear;
}LinkQueue;

void InitQueue(LinkQueue *Q){
    QueueNode *q = (QueueNode*) malloc(sizeof (QueueNode));
    Q->front = Q->rear = q;
    Q->front->next = NULL;
}

void EntryQ(LinkQueue *Q,ElemType e){
    QueueNode *q = (QueueNode*) malloc(sizeof (QueueNode));
    q->data = e;
    q->next = NULL;
    Q->rear->next = q;
    Q->rear = q;
}

bool OutQ(LinkQueue *Q,ElemType *e){
    if(Q->front == Q->rear){
        return false;
    }
    QueueNode *p = Q->front->next;
    *e = p->data;
    Q->front->next = p->next;
    if(Q->rear == p){
        Q->rear = Q->front;
    }
    free(p);
    return true;
}

void DestoryQueue(LinkQueue *Q){
    while(Q->front){
        Q->rear = Q->front->next;
        free(Q->front);
        Q->front = Q->rear;
    }
}

int main(){
    LinkQueue Q;
    InitQueue(&Q);
    char c,e;
    scanf("%c",&c);
    while(c!='#'){
        EntryQ(&Q,c);
        scanf("%c",&c);
    }
    while (Q.front != Q.rear){
        OutQ(&Q,&e);
        printf("%c ",e);
    }
    system("pause");
    return 0;
}
```

### 队列的顺序存储结构

#### 顺序队列(假溢出)

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208031658722.png" alt="img" style="zoom: 67%;" />

#### 循环队列

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208031654869.jpeg" alt="img" style="zoom: 67%;" />

1. 入队：队尾循环后移， rear =（rear+1）% MAXSIZE;
2. 出队：队首循环后移， front =（front+1）% MAXSIZE;
3. 队空：front = rear; // rear 和 front 指向同一个位置
4. 队满:(rear+1) % MAXSIZE = front; // rear 向后移一位正好是 front

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 100
typedef char ElemType;
typedef struct SqQueue{
    ElemType *base;
    int front;
    int rear;
}SqQueue;

void InitQueue(SqQueue *Q){
    Q->base = (ElemType*) malloc(sizeof (ElemType)*MAXSIZE);
    Q->front = Q->rear = 0;
}

bool EntryQ(SqQueue *Q,ElemType e){
    //判断是否队满
    if((Q->rear + 1) % MAXSIZE == Q->front)  return false;
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXSIZE;
    return true;
}

bool OutQ(SqQueue *Q,ElemType *e){
    //判断是否队空
    if(Q->rear == Q->front)  return false;
    *e = Q->base[Q->front];
    Q->front = (Q->front+1) % MAXSIZE;
    return true;
}

int main(){
    SqQueue Q;
    InitQueue(&Q);
    char c,e;
    scanf("%c",&c);
    while(c!='#'){
        EntryQ(&Q,c);
        scanf("%c",&c);
    }
    while (Q.front != Q.rear){
        OutQ(&Q,&e);
        printf("%c",e);
    }
    system("pause");
    return 0;
}
```

## 递归和分治

### 斐波那契数列

```c
#include <stdio.h>

int Fib(int i){
    if(i<2)   return i;
    else    return Fib(i-1) + Fib(i-2);
}
int main(){
    for(int i=0;i<20;i++){
        printf("%d ", Fib(i));
    }
    return 0;
}
```

### 字符串反向输出

```c
#include <stdio.h>

void print(){
    char c;
    scanf("%c",&c);
    if(c !='#') print();
    if(c !='#') printf("%c",c);
}
int main(){
    print();
    return 0;
}
```

### 二分法查找元素

```c
#include <stdio.h>
#include <stdlib.h>

int a[11] = {1,2,3,4,5,6,7,8,9,10,11};
int b;
void search(int low,int high){
    int mid = (low+high)/2;
    if(mid != low){
        if(a[mid] == b){
            printf("%d在第%d个位置",b,mid+1);
            return;
        } else if(a[mid] >b){
            search(low,mid);
        } else if(a[mid] <b){
            search(mid,high);
        }
    } else {
        printf("未找到");
    }
}

int main(){
    int size = sizeof (a)/sizeof(a[0]);
    scanf("%d",&b);
    search(0,size);
    return 0;
}
```

### 汉诺塔问题

```c
#include <stdio.h>
#include <stdlib.h>

//将n个盘子从x借助y移动到z
void move(int n,char x,char y,char z){
    if(n == 1){
        printf("%c--->%c\n",x,z);

    } else{
        move(n-1,x,z,y); //将n-1个盘子从x借助z移动到y
        printf("%c--->%c\n",x,z); //将底下的盘子从x移动到z
        move(n-1,y,x,z); //将n-1个盘子从y借助x移动到z
    }
}

int main(){
    int c;
    printf("请输入盘子的个数:");
    scanf("%d",&c);
    printf("移动盘子的顺序为:\n");
    move(c,'X','Y','Z');
    system("pause");
    return 0;
}
```

### 八皇后问题

```c
#include <stdio.h>
#include <stdlib.h>

int cot = 0;
int notdanger(int (*chess)[8],int row,int j){
    int i,k,flag = 1;
    //判断列
    for(i =0;i<8;i++){
        if(chess[i][j] != 0){
            flag = 0;
            break;
        }
    }
    //判断左上角
    for(i =row,k =j;i>=0 && k>=0;i--,k--){
        if(chess[i][k] != 0){
            flag = 0;
            break;
        }
    }
    //判断右下角
    for(i =row,k =j;i<8 && k<8;i++,k++){
        if(chess[i][k] != 0){
            flag = 0;
            break;
        }
    }
    //判断右上角
    for( i=row, k=j; i>=0 && k<8; i--, k++ ){
        if( chess[i][k] != 0 ){
            flag = 0;
            break;
        }
    }
    //判断左下角
    for( i=row, k=j; i<8 && k>=0; i++, k-- ){
        if( chess[i][k] != 0){
            flag = 0;
            break;
        }
    }
    return flag ? 1:0;
}
void EightQueen(int (*chess)[8],int row,int n){
    int chess2[8][8],i,j;

    for(i=0;i<8;i++){
        for(j=0;j<8;j++){
            chess2[i][j] = chess[i][j];
        }
    }

    if(row == 8){
        cot++;
        printf("第%d种结果为:\n",cot);
        for(i=0;i<8;i++){
            for(j=0;j<8;j++){
                printf("%d ",chess2[i][j]);
            }
            printf("\n");
        }
    } else{
        for(j = 0;j<n;j++){
            if(notdanger(chess2,row,j)){
                for(i=0;i<8;i++){
                    chess2[row][i] = 0;
                }
                chess2[row][j] = 1;
                EightQueen(chess2,row+1,n);
            }
        }
    }
}
int main(){
    int chess[8][8];

    for(int i=0;i<8;i++){
        for(int j=0;j<8;j++){
            chess[i][j] = 0;
        }
    }
    EightQueen(chess,0,8);
    printf("共有%d种结果",cot);
    //system("pause");
    return 0;
}
```

## 字符串

### BF算法

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208061418044.png" alt="image-20220806141840720" style="zoom:50%;" />

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXLEN 255
typedef struct String{
    char ch [MAXLEN + 1];
    int length;
}String;

int GetLength(String *S){
    int i = 1;
    while(S->ch[i] != '\0'){
        i++;
    }
    return i-1;
}

void Input(String *S){
    scanf("%s",&S->ch[1]);
    S->length = GetLength(S);
}

int BF(String *S,String *T,int position){
    int i = position;
    int j = 1;
    while(i<=S->length && j<=T->length){
        if(S->ch[i] == T->ch[j]){
            i++;
            j++;
        } else{
            i = i-j+2;
            j = 1;
        }
    }
    if(j > T->length){
        return i - T->length;
    } else{
        return 0;
    }
}

int main(){
    String S,T;
    printf("请输入主串:");
    Input(&S);
    printf("请输入子串:");
    Input(&T);
    int i = BF(&S,&T,1);

    if(i == 0){
        printf("未找到\n");
    } else{
        printf("该字符串在第%d个位置\n",i);
    }
    system("pause");
    return 0;
}
```

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208061819262.png" alt="image-20220806181845652" style="zoom: 33%;" />



### KMP算法

优化前：

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208061454559.png" alt="image-20220806145401053" style="zoom:50%;" />

优化后：

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208061510648.png" alt="image-20220806151047232" style="zoom:50%;" />

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXLEN 255
typedef struct String{
    char ch [MAXLEN + 1];
    int length;
}String;

int GetLength(String *S){
    int i = 1;
    while(S->ch[i] != '\0'){
        i++;
    }
    return i-1;
}

void Input(String *S){
    scanf("%s",&S->ch[1]);
    S->length = GetLength(S);
}

void GetNext(String *T,int *next){
    next[1] = 0;
    int j = 0;
    int i = 1;
    while (i<T->length){
        if(0 == j || T->ch[i] == T->ch[j]){
            i++;
            j++;
            //优化后
            if(T->ch[i] == T->ch[j]){
                next[i] = next[j];
            } else{
                next[i] = j;
            }
        } else{
            j = next[j];
        }
    }
}

int KMP(String *S,String *T,int position){
    int *next = (int *) malloc(sizeof (int) * (T->length + 1));
    GetNext(T,next);

    int i = position;
    int j = 1;

    while(i<=S->length && j<=T->length){
        if(j == 0 || S->ch[i] == T->ch[j]){
            i++;
            j++;
        } else{
            j = next[j];
        }
    }
    free(next);
    if(j > T->length){
        return i - T->length;
    } else{
        return 0;
    }
}

int main(){
    String S,T;
    printf("请输入主串:");
    Input(&S);
    printf("请输入子串:");
    Input(&T);
    int i = KMP(&S,&T,1);

    if(i == 0){
        printf("未找到\n");
    } else{
        printf("该字符串在第%d个位置\n",i);
    }
    system("pause");
    return 0;
}
```

## 数组

### 数组的类型定义

```c
typedef ElemType Array2[m][n];
等价于
typedef ElemType Array1[n];
```

### 数组的顺序存储

+ 以行序为主序
+ 以列序为主序 

n维数组A[0..b~1~-1,0..b~2~-1,..,0..b~n~-1]的数据元素存储位置的计算公式为：

LOC(j~1~,j~2~,...,j~n~) = LOC(0,0,..,0)+(b~2~\*...\*b~n~\*j~1~+b~3~\*...*b~n~\*j~2~+...+b~n~\*j~n-1~+j~n~)L

例如：二维数组A[0..m-1,0..n-1] (即m行n列): LOC(i,j) = LOC(0,0) + (n*i+j)L

三位数组A[0..k-1,0..m-1,0..n-1]: LOC(k,i,j) = LOC(0,0,0) + (k\*m\*n+n*i+j)

### 特殊矩阵的压缩方式

#### 对称矩阵

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208071040776.png" alt="img" style="zoom: 80%;" />

#### 三角矩阵

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208071043570.png" alt="image-20220807104345160" style="zoom: 67%;" />

#### 对角矩阵

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208071048889.png" alt="image-20220807104857017" style="zoom: 50%;" />

## 树

### 树的定义

树(Tree)是n(n>=0)个结点的有限集，它或为空树(n=0)或为非空树,对于非空树T：

+ 有且仅有一个根结点
+ 除根结点外的其余结点可分为m(m>0)个互不相交的有限集T~1~,T~2~...T~m~，其中每个集合又是一棵树，称为根的子树(SubTree).

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208071726839.png" alt="image-20220807172657390" style="zoom: 67%;" />

### 树的基本术语

+ 结点的度(degree)：结点拥有的子树数。例如，A的度为3，C的度为1，F的度为0.
+ 树的度：各结点的度的最大值。上图(b)的树的度为3
+ 叶子：度为0的结点称为叶子或终端结点。K,L,F,G,M,I,J为叶子
+ 非终端结点：度不为0的结点称为非终端结点或分支结点。除根结点外，非终端结点又称为内部结点。
+ 双亲和孩子：结点的子树为结点的孩子，该节点称为孩子的双亲，如B的双亲为A，孩子为E,F。
+ 兄弟：同一个双亲的孩子之间互称兄弟，例如，H,I,J互为兄弟。
+ 祖先：从根到垓结点所经分支上的所有结点，如，M的祖先为A,D,H。
+ 层次(level)：从根开始向下加1
+ 堂兄弟：双亲在同一层的结点互为堂兄弟。例如，G与E,F,H,I,J互为堂兄弟。
+ 树的深度(hegiht)：树中结点的最大层次称为树的深度。图(b)的深度为4
+ 森林：是m棵互不相交的树的集合。对树的每个结点来说，其子树的集合即为森林。

### 二叉树

#### 二叉树的定义

是n(n>=0)结点组成的集合，n=0时为空树，对于非空树T，有且仅有一个根结点，除根结点外，有互不相交的T~l~,T~r~两颗子树(可以为空树)，分别称为T的左右子树。

#### 二叉树的性质

+ 每个结点最多有两颗子树(即degree(T) <= 2)
+ 子树有左右之分，不可颠倒

#### 二叉树定理

+ 在二叉树的第i层上，最多有2^i-1^个结点
+ 深度为k的二叉树，最多有2^k^-1个结点
+ 终端结点n~0~，度为2的节点数为n~2~，则n~0~ = n~2~ + 1 

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208091724695.png" alt="image-20220808104053259" style="zoom:50%;" />

### 满二叉树和完全二叉树

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208081011533.png" alt="image-20220808101126957" style="zoom:67%;" />

#### 满二叉树

+ 含义：深度为k且含有2~k~-1个结点的二叉树。

+ 特点：每一层上的结点数都是最大结点数，即每一层i的结点数都为2~i~-1

#### 完全二叉树

+ 含义：深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1到n的结点一一对应时，称为完全二叉树。

+ 特点：

  + 叶子节点只可能在层次最大的两层上出现
  + 对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+l

+ 性质：

  + 具有n个结点的完全二叉树的深度为[log~2~n] + 1 

    证明：2^k-1^-1<n<=2^k^-1 --> 2^k-1^<=n<2^k^ --> k-1<=log~2~n<k --> k = [log~2~n] + 1

    <img src="https://gitee.com/newcwc/picture/raw/master/image/202208091245608.png" alt="image-20220808104707819" style="zoom: 67%;" />

### 二叉树的遍历

+ 前序遍历（先根，再左，最后右）
+ 中序遍历（先左，再根，最后右）
+ 后序遍历（先左，再右，最后根）
+ 层次遍历（每层从左往右遍历）

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208081820474.png" alt="image-20220808182004499" style="zoom:50%;" />

```C
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <stdlib.h>

typedef char ElemType;
typedef struct BiNode
{
    ElemType data;
    struct BiNode *lchild, *rchild;
} BiNode, *BiTree;

//前序递归输入
void CreatTree(BiTree *T)
{
    char c;
    scanf("%c", &c);
    if (c == ' ')
    {
        *T = NULL;
    }
    else
    {
        *T = (BiNode *)malloc(sizeof(BiNode));
        (*T)->data = c;
        CreatTree(&(*T)->lchild);
        CreatTree(&(*T)->rchild);
    }
}

void visit(char c, int level)
{
    printf("%c在第%d层\n", c, level);
}
//前序遍历
void PreOrder(BiTree T, int level)
{
    if (T)
    {
        visit(T->data, level);
        PreOrder(T->lchild, level + 1);
        PreOrder(T->rchild, level + 1);
    }
}
//中序遍历
void InOrder(BiTree T, int level)
{
    if (T)
    {
        InOrder(T->lchild, level + 1);
        visit(T->data, level);
        InOrder(T->rchild, level + 1);
    }
}
//后序遍历
void PostOrder(BiTree T, int level)
{
    if (T)
    {
        PostOrder(T->lchild, level + 1);
        PostOrder(T->rchild, level + 1);
        visit(T->data, level);
    }
}

int main()
{
    printf("请按照先序遍历输入二叉树元素：\n");
    BiTree T = NULL;
    int level = 1;
    CreatTree(&T);

    printf("前序遍历：\n");
    PreOrder(T, level);
    printf("中序遍历：\n");
    InOrder(T, level);
    printf("后序遍历：\n");
    PostOrder(T, level);
    system("pause");
    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 200
typedef struct BiNode{
    char data;
    struct BiNode *lchild,*rchild;
}BiNode,*BiTree;

typedef struct Queue{
    BiTree base[MAXSIZE];
    int front,rare;
}SqQueue;

void CreatTree(BiTree *T){
    char c;
    scanf("%c", &c);
    if (c == ' ') {
        *T = NULL;
    }
    else {
        *T = (BiNode*)malloc(sizeof(BiNode));
        (*T)->data = c;
        CreatTree(&(*T)->lchild);
        CreatTree(&(*T)->rchild);
    }
}

void EnQueue(SqQueue *L,BiTree e){
    if((L->rare+1) % MAXSIZE == L->front){
        printf("栈已满\n");
        exit(-1);
    }else{
        L->base[L->rare] = e;
        L->rare = (L->rare+1) % MAXSIZE;
    }
}

void OutStack(SqQueue *L,BiTree *T){
    *T = L->base[L->front];
    L->front = (L->front+1) % MAXSIZE;
}

void LevelOrder(BiTree L){
    SqQueue S;
    S.rare = S.front = 0;
    BiTree Temp;
    EnQueue(&S,L);//将二叉树的根入队
    while(S.front != S.rare){
        OutStack(&S,&Temp);
        printf("%c ",Temp->data);
        if(Temp->lchild){
            EnQueue(&S,Temp->lchild);
        }
        if(Temp->rchild){
            EnQueue(&S,Temp->rchild);
        }
    }
}

int main(){
    printf("请按照先序遍历输入二叉树元素：\n");
    BiTree T;
    CreatTree(&T);
	printf("层次遍历为：");
    LevelOrder(T);
    printf("\n");
    system("pause");
    return 0;
}
```

### 二叉树的其他操作

```C
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 200
typedef struct BiNode{
    char data;
    struct BiNode *lchild,*rchild;
}BiNode,*BiTree;

void CreatTree(BiTree *T){
    char c;
    scanf("%c", &c);
    if (c == ' ') {
        *T = NULL;
    }
    else {
        *T = (BiNode*)malloc(sizeof(BiNode));
        (*T)->data = c;
        CreatTree(&(*T)->lchild);
        CreatTree(&(*T)->rchild);
    }
}
//求深度
int Depth(BiTree T){
    if(!T){
        return 0;
    }else{
        return Depth(T->lchild) > Depth(T->rchild)
        ? Depth(T->lchild) + 1: Depth(T->rchild)+1;
    }
}
//求结点数
int Nodes(BiTree T){
    if(!T){
        return 0;
    }else{
        return 1 + Nodes(T->lchild) + Nodes(T->rchild);
    }
}
//复制二叉树
void Copy(BiTree *Tnew,const BiTree T){
    if(!T){
        *Tnew = NULL;
        return;
    } else{
        *Tnew = (BiTree) malloc(sizeof (BiNode));
        (*Tnew)->data = T->data;
        Copy(&(*Tnew)->lchild,T->lchild);
        Copy(&(*Tnew)->rchild,T->rchild);
    }
}
//利用后序遍历销毁二叉树(递归)
void Destroy(BiTree *root){
    if(!(*root)){
        return;
    } else{
        Destroy(&(*root)->lchild);
        Destroy(&(*root)->rchild);
        free(*root);
        *root = NULL;
    }
}
int main(){
    printf("请按照先序遍历输入二叉树元素：\n");
    BiTree T;
    CreatTree(&T);

    BiTree Tnew;
    Copy(&Tnew,T);
    printf("深度为：%d\n", Depth(Tnew));
    printf("结点数为：%d\n", Nodes(Tnew));
    Destroy(&T);
    Destroy(&Tnew);
    system("pause");
    return 0;
}
```

### 线索二叉树

若某个结点的没有左(右)子树，则其lchild(rchild)指向其前驱。

![image-20220812204934783](https://gitee.com/newcwc/picture/raw/master/image/202208122049787.png)

![image-20220812205546918](https://gitee.com/newcwc/picture/raw/master/image/202208122055141.png)

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209061441057.png" alt="image-20220812210212304" style="zoom:50%;" />

```c
#include <stdio.h>
#include <stdlib.h>

//枚举:Link = 0 Thread = 1
typedef enum {Link,Thread} PointerTag;
typedef struct BiNode{
    char data;
    struct BiNode *lchild,*rchild;
    PointerTag ltag;
    PointerTag rtag;
}BiNode,*BiTree;
//全局变量,指向前驱结点
BiTree Pre;

void CreatTree(BiTree *T){
    char c;
    scanf("%c",&c);
    if(c == ' '){
        *T = NULL;
    }else{
        *T = (BiNode*) malloc(sizeof (BiNode));
        (*T)->data = c;
        (*T)->ltag = Link;
        (*T)->rtag = Link;
        CreatTree(&(*T)->lchild);
        CreatTree(&(*T)->rchild);
    }
}

void InOrder(BiTree T){
    if(T){
        InOrder(T->lchild);
        if(!T->lchild){
            T->ltag = Thread;
            T->lchild = Pre;
        }
        if(!Pre->rchild){
            Pre->rtag = Thread;
            Pre->rchild = T;
        }
        Pre = T;
        InOrder(T->rchild);
    }
}

void InOrderThreading(BiTree *p,BiTree T){
    *p = (BiTree) malloc(sizeof (BiNode));
    (*p)->ltag = Link;
    (*p)->rtag = Thread;
    (*p)->rchild = *p;
    if(!T){
        (*p)->lchild = *p;
    } else{
        (*p)->lchild = T;
        Pre = *p;
        InOrder(T);
        Pre->rtag = Thread;
        Pre->rchild = *p;
        (*p)->rchild = Pre;
    }
}
int main(){
    BiTree p,T = NULL;
    printf("请按前序遍历输入:");
    CreatTree(&T);

    InOrderThreading(&p,T);
    printf("%c",T->lchild->lchild->rchild->data);
    system("pause");
    return 0;
}
```

### 树的存储结构

#### 双亲表示法

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208131328801.png" alt="image-20220813132851841" style="zoom: 67%;" />

```c
struct PTNode{
    DataType data;
    int parent;
};
struct PTree{
    PTNode [MAXSZIE];
    int root; //根结点位置
    int n; //结点个数
}
```

#### 孩子链表

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208131331808.png" alt="image-20220813133157482" style="zoom:50%;" />

```c
//孩子结点结构
struct CTNode{
    int child;
    CTNode *next;
};
//双亲结点结构
struct CTBox{
    DataType data;
    int parent;
    CTNode *child;
};
//整体树结构
struct CTree{
    CTBox[MAXSIZE];
    int root;
    int n;
};
```

#### 孩子兄弟表示法(树转化为二叉树的基础)

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208131344278.png" alt="image-20220813134452427" style="zoom: 50%;" />

```c
//结点的child指向它的第一个孩子，sibing指向第一个兄弟
struct CSNode{
	DataType data;
    CSNode *child,*sibling;
}
```

### 树、森林与二叉树之间的转换

#### 树转二叉树

1. 兄弟之间连线
2. 对于任一结点k，除了其左孩子外，去掉所有孩子与其的关系
3. 以根结点的左孩子为中心，顺时针旋转45&deg;,再与根节点相连

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208131842292.png" alt="image-20220813184206377" style="zoom: 67%;" />

#### 二叉树转树

1. 若k结点是双亲的左孩子，则将k的右孩子，右孩子的右孩子……连接到k的双亲结点上
2. 去掉所有双亲结点与右孩子的关系
3. 整理成树状

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208131845418.png" alt="image-20220813184500521" style="zoom:67%;" />

#### 森林转二叉树

1. 将森林中的各棵树转化为二叉树
2. 链接这些二叉树的根节点
3. 第一棵树的根为二叉树的根，进行调整

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208131849861.png" alt="image-20220813184911929" style="zoom:67%;" />

#### 二叉树转森林

1. 若r是二叉树的根，则取消所有r的右孩子，右孩子的右孩子……之间的关系
2. 此时有m课孤立的二叉树，把每个二叉树转成树，形成森林

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208131851032.png" alt="image-20220813185148939" style="zoom:67%;" />

### 树和森林的遍历

#### 树的遍历

+ 先根遍历：若树不为空，则先访问根节点然后再依次按照先根遍历来遍历各个子树(相当于转换为二叉树的先序遍历)

+ 后根遍历：若树不为空，先依次后根遍历各个子树，再访问根结点(相当于转换为二叉树的中序遍历)

+ 层次遍历：自上而下，从左往右

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208131904486.png" alt="image-20220813190429385" style="zoom: 50%;" />

#### 森林的遍历

+ 依次对每棵树进行遍历

### 哈夫曼树

#### 哈夫曼树的相关概念

1. 路径：从树的一个结点到另一个结点之间的分支构成这两个结点之间的路径
2. 路径长度：路径上的分支数目
3. 树的路径长度：从树根到每一个结点的路径长度之和
4. 结点的带权路径长度：从垓结点到树根之间的路径长度与结点上权的乘积
5. 树的带权路径长度(WPL)：树的所有叶子结点的带权路径长度之和
6. 哈夫曼树：又称最优二叉树，即带权路径WPL最短的树

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208141926423.png" alt="image-20220814192655299" style="zoom:50%;" />

#### 哈夫曼树的构造过程

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208141934211.png" alt="image-20220814193408511" style="zoom:50%;" />

#### 哈夫曼编码

1. 前缀编码：任一编码都不是其他编码的前缀(最左子串)，则称编码是前缀编码
2. 哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码
3. 哈夫曼编码满足两个性质：(1)为前缀编码  (2)为最优前缀编码

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208151116972.png" alt="image-20220815111616103" style="zoom:50%;" />

#### 哈夫曼编码代码实现

```c

```

## 图

### 图的定义

+ 图(Graph)G由两个集合V和E组成，记为G = (V,E),其中V是顶点的**有穷非空集合**，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空集，则图G只有顶点而没有边。

+ 图分为有向图(a)和无向图(b):

​	(a)：G~a~={V~a~,E~a~}，其中V~a~ = {A,B,C,D}，E~a~ = {<B,A>,<B,C>,<C,A>,<A,D>}

​	(b)：G~b~={V~b~,E~b~}，其中V~b~ = {A,B,C,D}，E~b~ = {(A,B),(B,C),(C,D),(D,A),(A,C)}

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209061440479.png" alt="image-20220816205421312" style="zoom:50%;" />

### 图的术语

1. 子图：假设有两个图G = V(V,E)和G' = V(V',E') ,如果V'$\subseteq$ V且E'$\subseteq$ E,则称G'为G的子图。如：

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208162108255.png" alt="image-20220816210836113" style="zoom:33%;" />

2. 无向完全图：具有n(n-1)/2条边

   有向完全图：具有n(n-1)条边

3. 稀疏图和稠密图：边或弧数小于n*logn（n是顶点的个数）的图称为稀疏图，反之称为稠密图。

4. 权和图：每条边都赋予某种含义的值，该数值称为该边上的权，这种带权的图称为网

5. 邻接点：对于无向图G,如果边(v,v')$\subseteq$E,则称顶点v和v'互为邻接点，即v和v'相邻接。边(v,v')依附于v和v'，或者说边(v,v')与顶点v和v'相关联。

6. 度，入度和出度(drgree)：顶点v的度是指和v相关联的边的数目，记为TD(v).例如，上图(b)中TD(B)=2,TD(C)=3。对于有向图，顶点v的度分为入度和出度。入度是以顶点v为头的弧的数目，记为ID(v)；出度是以顶点v为尾的弧的数目，记为OD(v)。顶点v的度为TD(v)=ID(v)+OD(v)。例如，图(a)中A的入度ID(A)=2，出度OD(A)=1,度TD(A)=ID(A)+OD(A)=3.

7. 路径：持续的边构成的顶点序列

   路径长度：路径上边的数量或权值之和

8. 回路或环(loop)：第一个顶点和最后一个顶点相同的路径

9. 简单路径：序列中顶点不重复出现的路径称为简单路径

   简单回路(简单环)：除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路

10. 连通：在无向图G中，如果顶点v到顶点v'有路径，则称v和v'是连通的

    连通图：如果对于图中任意两个顶点v~i~、v~j~$\subseteq$V,v~i~和v~j~存在路径，则称G是连通图

    连通分量：无向图中的极大连通子图

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209061441183.png" alt="image-20220817122549423" style="zoom:50%;" />

11. 强连通图：在有向图G中，如果对于每一对v~i~,v~j~~j~$\subseteq$V,v~i~$\neq$v~j~,从v~i~到v~j~和从v~j~到v~i~都存在路径，则称G是强连通图。

    强连通分量：有向图中的极大强连通分量称为有向图的强连通分量。

12. 极小连通子图：若G~1~是G的连通子图，在G~1~上删除任意一条边，G~1~不再连通，则称G~1~是G的极小连通子图。

    极大连通子图：若G~1~(V~1~,E~1~)是G(V,E)的连通子图，任取顶点v$\subseteq$(V-V~1~),若把v加入V~1~中，G~1~不再连通，则称G~1~为G的极大连通子图。

13. 连通图的生成树：一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边，这样的连通子图称为连通图的生成树。

    **连通图中的生成树必须满足以下 2 个条件：**

    1. 包含连通图中所有的顶点；
    2. 任意两顶点之间有且仅有一条通路；

    一棵有n个顶点的生成树有且仅有n-1条边。如果一个图有n个顶点和小于n-1条边，则是非连通图。如果多于n-1条边，则一定有环。但是，有n-1条边的图不一定是生成树(不连通)。

    <img src="https://gitee.com/newcwc/picture/raw/master/image/202208171818338.png" alt="image-20220817181757078" style="zoom:50%;" />

14. 有向树：有一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树。

15. 生成森林：一个有向图的生成森林是由若干个有向树组成，含有图中全部顶点，但只有足以构成若干棵不相干的有向树的弧。

    <img src="https://gitee.com/newcwc/picture/raw/master/image/202208171824542.png" alt="image-20220817182410201" style="zoom: 67%;" />

### 图的存储结构

#### 邻接矩阵(Adjacency Matrix)

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208181239152.png" alt="image-20220818123949258" style="zoom:50%;" />

无向图：degree(v~i~) = 矩阵中第i行中1的个数

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208181245695.png" alt="image-20220818124518032" style="zoom: 33%;" />

有向图：ID(v~i~) = 第v~i~列中1的个数，OD(v~i~) = 第v~i~行中1的个数。

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208181249845.png" alt="image-20220818124923474" style="zoom: 33%;" />

带权网：

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208181253247.png" alt="image-20220818125354635" style="zoom: 50%;" />

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208181253662.png" alt="image-20220818125338045" style="zoom:33%;" />

代码实现(无向有权图)：

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXWEIGHT 9999  //最大权值
#define MAXVERTEX 20    //最大顶点数
typedef char VetexType; //顶点类型
typedef int MatrixType; //矩阵类型

typedef struct AMGraph
{
    VetexType vertex[MAXVERTEX];
    MatrixType edge[MAXVERTEX][MAXVERTEX];
    int vertexes, edges; //顶点和边的个数
} AMGraph;

void CreatGraph(AMGraph *G)
{
    printf("Please input the number of vertices:\n");
    scanf("%d", &G->vertexes);
    printf("Please input the number of edges:\n");
    scanf("%d", &G->edges);
    printf("Please input the name of vertices\n");
    for (int i = 0; i < G->vertexes; i++)
    {
        scanf(" %c", &G->vertex[i]);
    }
    for (int i = 0; i < G->vertexes; i++)
    {
        for (int j = 0; j < G->vertexes; j++)
        {
            G->edge[i][j] = MAXWEIGHT;
        }
    }
    char v1, v2;
    int weight;
    printf("Please input the edge:\n");
    for (int i = 0; i < G->edges; i++)
    {
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c %d", &v1, &v2, &weight);
        for (int j = 0; j < G->vertexes; j++)
        {
            if (G->vertex[j] == v1)
            {
                index_v1 = j;
            }
            if (G->vertex[j] == v2)
            {
                index_v2 = j;
            }
            if (index_v1 != -1 && index_v2 != -1)
            {
                break;
            }
        }
        G->edge[index_v1][index_v2] = weight;
        G->edge[index_v2][index_v1] = weight; //有向则删去此行
    }
}
int main()
{
    AMGraph G;
    CreatGraph(&G);
    for (int i = 0; i < G.vertexes; i++)
    {
        for (int j = 0; j < G.vertexes; j++)
        {
            printf("%d\t", G.edge[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```

#### 邻接表

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208191642663.png" alt="image-20220819164233945" style="zoom:50%;" />

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208191800232.png" alt="image-20220819180044883" style="zoom:50%;" />

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXVERTEX 20
#define MAXWEIGHT 999

typedef char VertexType;
typedef struct EdgeNode{        //边表结点
    int adjvertex;          
    int weight;
    struct EdgeNode *next;
}EdgeNode;

typedef struct VertexNode {     //顶点表
    VertexType vertex;
    EdgeNode *firstEdge;
} VertexNode;

typedef struct Graph{
    VertexNode AdjList[MAXVERTEX];
    int numVertex, numEdges;
} GraphAdjList;

void CreatGraph(GraphAdjList *G){
    printf("Please input the number of vertexs:\n");
    scanf("%d", &G->numVertex);
    printf("Please input the number of Edges:\n");
    scanf("%d", &G->numEdges);

    printf("Please input the name of vertexs:\n");
    for (int i = 0; i < G->numVertex;i++){
        scanf(" %c", &G->AdjList[i].vertex);
        G->AdjList[i].firstEdge = NULL;
    }

    char v1, v2;
    int weight;
    EdgeNode *e;
    printf("Please input the edges:\n");
    for (int i = 0; i < G->numEdges;i++){
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c %d", &v1, &v2, &weight);
        for (int j = 0; j < G->numVertex;j++){
            if(G->AdjList[j].vertex == v1){
                index_v1 = j;
            }
            if(G->AdjList[j].vertex == v2){
                index_v2 = j;
            }
            if(index_v1 != -1 && index_v2 != -1){
                break;
            }
        }
        e = (EdgeNode *)malloc(sizeof(EdgeNode));
        e->adjvertex = index_v2;
        e->weight = weight;
        e->next = G->AdjList[index_v1].firstEdge;
        G->AdjList[index_v1].firstEdge = e;

        e = (EdgeNode *)malloc(sizeof(EdgeNode));
        e->adjvertex = index_v1;
        e->weight = weight;
        e->next = G->AdjList[index_v2].firstEdge;
        G->AdjList[index_v2].firstEdge = e;
       
    }
}

int main(){
    GraphAdjList G;
    CreatGraph(&G);
    EdgeNode *e;
    char v;
    printf("----------------------\n");
    for (int i = 0; i < G.numVertex;i++){
        v = G.AdjList[i].vertex;
        printf("%c:", v);
        e = G.AdjList[i].firstEdge;
        while(e){
            printf("%c--%c\t", v, G.AdjList[e->adjvertex].vertex);
            e = e->next;
        }
        printf("\n");
    }
    return 0;
}
```

#### 十字链表(有向图)

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208201505169.png" alt="image-20220820150532847" style="zoom:50%;" />

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXVERTEX 20
//弧结点
typedef struct ArcBox{
    int tailvex, headvex;
    struct ArcBox *innext, *outnext;
} ArcBox;
//顶点结点
typedef struct VexNode{
    char data;
    ArcBox *firstin, *firstout;
} VexNode;

typedef struct OLGGraph{
    VexNode List[MAXVERTEX];
    int vexnum, arcnum;
} OLGGraph;

void CreatGraph(OLGGraph *G){
    printf("Please input the number of vertaxs\n");
    scanf("%d", &G->vexnum);
    printf("Please input the number of arcs\n");
    scanf("%d", &G->arcnum);

    printf("Please input the name of Vertax\n");
    for (int i = 0; i < G->vexnum;i++){
        scanf(" %c", &G->List[i].data);
        G->List[i].firstin = NULL;
        G->List[i].firstout = NULL;
    }

    printf("Please input the arc\n");
    char v1, v2;
    for (int i = 0; i < G->arcnum;i++){
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c", &v1, &v2);
        for (int j = 0; j < G->vexnum;j++){
            if(G->List[j].data == v1){
                index_v1 = j;
            }
            if(G->List[j].data == v2){
                index_v2 = j;
            }
            if(index_v1 != -1 && index_v2 != -1){
                break;
            }
        }
        ArcBox *pnew1 = (ArcBox *)malloc(sizeof(ArcBox));
        pnew1->headvex = index_v1;
        pnew1->tailvex = index_v2;
        pnew1->outnext = G->List[index_v1].firstout;
        pnew1->innext = G->List[index_v2].firstin;
        G->List[index_v1].firstout = pnew1;
        G->List[index_v2].firstin = pnew1;
    }
}

int main(){
    OLGGraph G;
    CreatGraph(&G);

    ArcBox *in,*out;
 
    for (int i = 0; i < G.vexnum;i++){
        printf("%c:", G.List[i].data);
        in = G.List[i].firstin;
        out = G.List[i].firstout;
        while(in){
            printf("%c--%c\t", G.List[in->headvex].data, G.List[in->tailvex].data);
            in = in->innext;
        }
        while(out){
            printf("%c--%c\t", G.List[out->headvex].data, G.List[out->tailvex].data);
            out = out->outnext;
        }
        printf("\n");
    }
    return 0;
}
```

#### 邻接多重表

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208212206646.png" alt="image-20220821220618842" style="zoom:50%;" />

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208212205524.gif" alt="无向图及其对应的邻接多重表" style="zoom: 67%;" />

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXVERTAX 20

typedef struct EBox{
    int ivex, jvex;
    struct EBox *ilink, *jlink;
} EBox;

typedef struct VexBox{
    char data;
    EBox *firstedge;
} VexBox;

typedef struct AMLGraph{
    VexBox List[MAXVERTAX];
    int vexnum, edgenum;
} AMLGraph;

void CreatGraph(AMLGraph *G){
    printf("Please input the number of vertaxs\n");
    scanf("%d", &G->vexnum);
    printf("Please input the number of edges\n");
    scanf("%d", &G->edgenum);

    printf("Please input the name of Vertax\n");
    for (int i = 0; i < G->vexnum;i++){
        scanf(" %c", &G->List[i].data);
        G->List[i].firstedge = NULL;
    }

    printf("Please input the edge\n");
    char v1, v2;
    for (int i = 0; i < G->edgenum;i++){
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c", &v1, &v2);
        for (int j = 0; j < G->vexnum;j++){
            if(G->List[j].data == v1){
                index_v1 = j;
            }
            if(G->List[j].data == v2){
                index_v2 = j;
            }
            if(index_v1 != -1 && index_v2 != -1){
                break;
            }
        }
        EBox *pnew = (EBox *)malloc(sizeof(EBox));
        pnew->ivex = index_v1;
        pnew->jvex = index_v2;
        pnew->ilink = G->List[index_v1].firstedge;
        pnew->jlink = G->List[index_v2].firstedge;
        G->List[index_v1].firstedge = pnew;
        G->List[index_v2].firstedge = pnew;
    }
}

int main(){
    AMLGraph G;
    CreatGraph(&G);

    return 0;
}
```

### 图的遍历

#### 深度优先遍历

<img src="https://gitee.com/newcwc/picture/raw/master/image/202208221444415.png" alt="image-20220822144419121" style="zoom:50%;" />

##### 邻接矩阵

```C
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAXVERTEX 20 //最大顶点数
typedef char VetexType; //顶点类型
typedef int MatrixType; //矩阵类型

typedef struct AMGraph{
    VetexType vertex[MAXVERTEX];
    MatrixType edge[MAXVERTEX][MAXVERTEX];
    int vertices, edges; //顶点和边的个数
} AMGraph;

void CreatGraph(AMGraph *G){
    printf("Please input the number of vertices:\n");
    scanf("%d", &G->vertices);
    printf("Please input the number of edges:\n");
    scanf("%d", &G->edges);
    printf("Please input the name of vertices\n");
    for (int i = 0; i < G->vertices;i++){
        scanf(" %c", &G->vertex[i]);
    }
    for (int i = 0; i < G->vertices;i++){
        for (int j = 0; j < G->vertices;j++){
            G->edge[i][j] = 0;
        }
    }
    char v1, v2;
    printf("Please input the edge:\n");
    for (int i = 0; i < G->edges;i++){
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c", &v1, &v2);
        for (int j = 0; j < G->vertices;j++){
            if(G->vertex[j]==v1){
                index_v1 = j;
            }
            if(G->vertex[j]==v2){
                index_v2 = j;
            }
            if(index_v1 != -1 && index_v2 != -1){
                break;
            }
        }
        G->edge[index_v1][index_v2] = 1;
        G->edge[index_v2][index_v1] = 1; //有向则删去此行
    }
}

void DFS_AM(AMGraph *G,int v,bool *visit){
    printf("%c ", G->vertex[v]);
    visit[v] = true;

    for (int i = 0; i < G->vertices;i++){
        if(G->edge[v][i] && !visit[i]){
            DFS_AM(G, i, visit);
        }
    }
}

void DFS_AMGraph(AMGraph *G){
    bool *visit = (bool *)malloc(sizeof(bool)* G->vertices);
    memset(visit, false, sizeof(bool) * G->vertices);

    DFS_AM(G, 0, visit);
    free(visit);
}

int main(){
    AMGraph G;
    CreatGraph(&G);
    DFS_AMGraph(&G);

    return 0;
}
```

##### 邻接表

```c
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAXVERTEX 20
typedef struct EdgeNode
{
    int adjvertex;
    struct EdgeNode *next;
} EdgeNode;

typedef struct ALGNode
{
    char name;
    EdgeNode *firstEdge;
} ALGNode;

typedef struct ALGraph
{
    ALGNode vertex[MAXVERTEX];
    int edges, vertexes;
} ALGraph;

void CreatALGraph(ALGraph *G)
{
    printf("Please input the number of vertexs:\n");
    scanf("%d", &G->vertexes);
    printf("Please input the number of Edges:\n");
    scanf("%d", &G->edges);

    printf("Please input the name of vertexs:\n");
    for (int i = 0; i < G->vertexes; i++)
    {
        scanf(" %c", &G->vertex[i].name);
        G->vertex[i].firstEdge = NULL;
    }

    char v1, v2;
    EdgeNode *e;
    printf("Please input the edges:\n");
    for (int i = 0; i < G->edges; i++)
    {
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c", &v1, &v2);
        for (int j = 0; j < G->vertexes; j++)
        {
            if (G->vertex[j].name == v1)
            {
                index_v1 = j;
            }
            if (G->vertex[j].name == v2)
            {
                index_v2 = j;
            }
            if (index_v1 != -1 && index_v2 != -1)
            {
                break;
            }
        }
        e = (EdgeNode *)malloc(sizeof(EdgeNode));
        e->adjvertex = index_v2;
        e->next = G->vertex[index_v1].firstEdge;
        G->vertex[index_v1].firstEdge = e;

        e = (EdgeNode *)malloc(sizeof(EdgeNode));
        e->adjvertex = index_v1;
        e->next = G->vertex[index_v2].firstEdge;
        G->vertex[index_v2].firstEdge = e;
    }
}

void DFS_AL(ALGraph *G, int v, bool *visit)
{
    printf("%c\t", G->vertex[v].name);
    visit[v] = true;

    EdgeNode *p = G->vertex[v].firstEdge;
    while (p)
    {
        int adj = p->adjvertex;
        if (!visit[adj])
        {
            DFS_AL(G, adj, visit);
        }
        p = p->next;
    }
}

void DFS_ALGraph(ALGraph *G)
{
    bool *visit = (bool *)malloc(sizeof(bool) * G->vertexes);
    memset(visit, false, sizeof(bool) * G->vertexes);

    DFS_AL(G, 0, visit);
}

int main()
{
    ALGraph G;
    CreatALGraph(&G);
    DFS_ALGraph(&G);

    return 0;
}
```

#### 广度优先遍历

##### 邻接矩阵

```C
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAXVERTEX 20

typedef int ElemType;
typedef struct QueueNode
{
    ElemType data;
    struct QueueNode *next;
} QueueNode;

typedef struct LinkQueue
{
    QueueNode *front;
    QueueNode *rear;
} LinkQueue;

void InitQueue(LinkQueue *Q)
{
    QueueNode *q = (QueueNode *)malloc(sizeof(QueueNode));
    Q->front = Q->rear = q;
    Q->front->next = NULL;
}

void EntryQ(LinkQueue *Q, ElemType e)
{
    QueueNode *q = (QueueNode *)malloc(sizeof(QueueNode));
    q->data = e;
    q->next = NULL;
    Q->rear->next = q;
    Q->rear = q;
}

bool OutQ(LinkQueue *Q, ElemType *e)
{
    if (Q->front == Q->rear)
    {
        return false;
    }
    QueueNode *p = Q->front->next;
    *e = p->data;
    Q->front->next = p->next;
    if (Q->rear == p)
    {
        Q->rear = Q->front;
    }
    free(p);
    return true;
}

void DestoryQueue(LinkQueue *Q)
{
    while (Q->front)
    {
        Q->rear = Q->front->next;
        free(Q->front);
        Q->front = Q->rear;
    }
}

typedef struct AMGraph
{
    char vertex[MAXVERTEX];
    int edge[MAXVERTEX][MAXVERTEX];
    int vertexes, edges;
} AMGraph;

void CreatAMGraph(AMGraph *G)
{
    printf("Please input the number of vertices:\n");
    scanf("%d", &G->vertexes);
    printf("Please input the number of edges:\n");
    scanf("%d", &G->edges);

    printf("Please input the name of vertices\n");
    for (int i = 0; i < G->vertexes; i++)
    {
        scanf(" %c", &G->vertex[i]);
    }
    for (int i = 0; i < G->vertexes; i++)
    {
        for (int j = 0; j < G->vertexes; j++)
        {
            G->edge[i][j] = 0;
        }
    }

    char v1, v2;
    printf("Please input the edge:\n");
    for (int i = 0; i < G->edges; i++)
    {
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c", &v1, &v2);
        for (int j = 0; j < G->vertexes; j++)
        {
            if (G->vertex[j] == v1)
            {
                index_v1 = j;
            }
            if (G->vertex[j] == v2)
            {
                index_v2 = j;
            }
            if (index_v1 != -1 && index_v2 != -1)
            {
                break;
            }
        }
        G->edge[index_v1][index_v2] = 1;
        G->edge[index_v2][index_v1] = 1; //有向则删去此行
    }
}

void BFS_AM(AMGraph *G, int v, bool *visit)
{
    LinkQueue Q;
    InitQueue(&Q);
    EntryQ(&Q, v);
    visit[v] = true;

    int pop;
    while (!(Q.front == Q.rear))
    {
        OutQ(&Q, &pop);
        {
            printf("%c ", G->vertex[pop]);
            for (int k = 0; k < G->vertexes; k++)
            {
                if (G->edge[pop][k] && !visit[k])
                {
                    EntryQ(&Q, k);
                    visit[k] = true;
                }
            }
        }
    }
}

void BFS_AMGraph(AMGraph *G)
{
    bool *visit = (bool *)malloc(sizeof(bool) * G->vertexes);
    memset(visit, false, sizeof(bool) * G->vertexes);

    BFS_AM(G, 0, visit);
    free(visit);
}

int main()
{
    AMGraph G;
    CreatAMGraph(&G);

    BFS_AMGraph(&G);
    return 0;
}
```

##### 邻接表

```C
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAXVERTEX 20    //最大顶点数
typedef char VetexType; //顶点类型
typedef int MatrixType; //矩阵类型
typedef int ElemType;

typedef struct QueueNode
{
    ElemType data;
    struct QueueNode *next;
} QueueNode;

typedef struct LinkQueue
{
    QueueNode *front;
    QueueNode *rear;
} LinkQueue;

void InitQueue(LinkQueue *Q)
{
    QueueNode *q = (QueueNode *)malloc(sizeof(QueueNode));
    Q->front = Q->rear = q;
    Q->front->next = NULL;
}

void EntryQ(LinkQueue *Q, ElemType e)
{
    QueueNode *q = (QueueNode *)malloc(sizeof(QueueNode));
    q->data = e;
    q->next = NULL;
    Q->rear->next = q;
    Q->rear = q;
}

bool OutQ(LinkQueue *Q, ElemType *e)
{
    if (Q->front == Q->rear)
    {
        return false;
    }
    QueueNode *p = Q->front->next;
    *e = p->data;
    Q->front->next = p->next;
    if (Q->rear == p)
    {
        Q->rear = Q->front;
    }
    free(p);
    return true;
}

void DestoryQueue(LinkQueue *Q)
{
    while (Q->front)
    {
        Q->rear = Q->front->next;
        free(Q->front);
        Q->front = Q->rear;
    }
}

typedef struct EdgeNode
{
    int adjvertex;
    struct EdgeNode *next;
} EdgeNode;

typedef struct ALGNode
{
    char name;
    EdgeNode *firstEdge;
} ALGNode;

typedef struct ALGraph
{
    ALGNode vertex[MAXVERTEX];
    int edges, vertexes;
} ALGraph;

void CreatALGraph(ALGraph *G)
{
    printf("Please input the number of vertexs:\n");
    scanf("%d", &G->vertexes);
    printf("Please input the number of Edges:\n");
    scanf("%d", &G->edges);

    printf("Please input the name of vertexs:\n");
    for (int i = 0; i < G->vertexes; i++)
    {
        scanf(" %c", &G->vertex[i].name);
        G->vertex[i].firstEdge = NULL;
    }

    char v1, v2;
    EdgeNode *e;
    printf("Please input the edges:\n");
    for (int i = 0; i < G->edges; i++)
    {
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c", &v1, &v2);
        for (int j = 0; j < G->vertexes; j++)
        {
            if (G->vertex[j].name == v1)
            {
                index_v1 = j;
            }
            if (G->vertex[j].name == v2)
            {
                index_v2 = j;
            }
            if (index_v1 != -1 && index_v2 != -1)
            {
                break;
            }
        }
        e = (EdgeNode *)malloc(sizeof(EdgeNode));
        e->adjvertex = index_v2;
        e->next = G->vertex[index_v1].firstEdge;
        G->vertex[index_v1].firstEdge = e;

        e = (EdgeNode *)malloc(sizeof(EdgeNode));
        e->adjvertex = index_v1;
        e->next = G->vertex[index_v2].firstEdge;
        G->vertex[index_v2].firstEdge = e;
    }
}

void BFS_AM(ALGraph *G, int v, bool *visit)
{
    LinkQueue Q;
    InitQueue(&Q);

    EntryQ(&Q, v);
    visit[v] = true;

    int pop;
    EdgeNode *p;
    while (!(Q.front == Q.rear))
    {
        OutQ(&Q, &pop);
        printf("%c ", G->vertex[pop].name);
        p = G->vertex[pop].firstEdge;
        while (p)
        {
            if (!visit[p->adjvertex])
            {
                EntryQ(&Q, p->adjvertex);
                visit[p->adjvertex] = true;
            }
            p = p->next;
        }
    }
}

void BFS_AMGraph(ALGraph *G)
{
    bool *visit = (bool *)malloc(sizeof(bool) * G->vertexes);
    memset(visit, false, sizeof(bool) * G->vertexes);

    BFS_AM(G, 0, visit);
    free(visit);
}

int main()
{
    ALGraph G;
    CreatALGraph(&G);

    BFS_AMGraph(&G);
    return 0;
}
```

### 马踏棋盘问题(骑士周游问题)

```c
#include <stdio.h>
#include <time.h>

#define X 8
#define Y 8

int chess[X][Y];

int nextxy(int *x, int *y, int count)
{
    switch (count)
    {
    case 0:
        if (*x + 2 <= X - 1 && *y - 1 >= 0 && chess[*x + 2][*y - 1] == 0)
        {
            *x = *x + 2;
            *y = *y - 1;
            return 1;
        }
        break;
    case 1:
        if (*x + 2 <= X - 1 && *y + 1 <= Y - 1 && chess[*x + 2][*y + 1] == 0)
        {
            *x = *x + 2;
            *y = *y + 1;
            return 1;
        }
        break;

    case 2:
        if (*x + 1 <= X - 1 && *y - 2 >= 0 && chess[*x + 1][*y - 2] == 0)
        {
            *x = *x + 1;
            *y = *y - 2;
            return 1;
        }
        break;

    case 3:
        if (*x + 1 <= X - 1 && *y + 2 <= Y - 1 && chess[*x + 1][*y + 2] == 0)
        {
            *x = *x + 1;
            *y = *y + 2;
            return 1;
        }
        break;

    case 4:
        if (*x - 2 >= 0 && *y - 1 >= 0 && chess[*x - 2][*y - 1] == 0)
        {
            *x = *x - 2;
            *y = *y - 1;
            return 1;
        }
        break;

    case 5:
        if (*x - 2 >= 0 && *y + 1 <= Y - 1 && chess[*x - 2][*y + 1] == 0)
        {
            *x = *x - 2;
            *y = *y + 1;
            return 1;
        }
        break;

    case 6:
        if (*x - 1 >= 0 && *y - 2 >= 0 && chess[*x - 1][*y - 2] == 0)
        {
            *x = *x - 1;
            *y = *y - 2;
            return 1;
        }
        break;

    case 7:
        if (*x - 1 >= 0 && *y + 2 <= Y - 1 && chess[*x - 1][*y + 2] == 0)
        {
            *x = *x - 1;
            *y = *y + 2;
            return 1;
        }
        break;
    default:
        break;
    }
    return 0;
}

int TravelChessBoard(int x, int y, int tag)
{
    int x1 = x, y1 = y, flag = 0, count = 0;
    chess[x][y] = tag;

    if (tag == X * Y)
    {
        for (int i = 0; i < X; i++)
        {
            for (int j = 0; j < Y; j++)
            {
                printf("%d\t", chess[i][j]);
            }
            printf("\n");
        }
        return 1;
    }

    flag = nextxy(&x1, &y1, count);

    while (0 == flag && count < 7)
    {
        count++;
        flag = nextxy(&x1, &y1, count);
    }

    while (flag)
    {
        if (TravelChessBoard(x1, y1, tag + 1))
        {
            return 1;
        }
        x1 = x;
        y1 = y;
        count++;

        flag = nextxy(&x1, &y1, count);

        while (0 == flag && count < 7)
        {
            count++;
            flag = nextxy(&x1, &y1, count);
        }
    }

    if (0 == flag)
    {
        chess[x][y] = 0;
    }
    return 0;
}

int main()
{
    int i, j;
    clock_t start, finish;
    start = clock();

    for (i = 0; i < X; i++)
    {
        for (j = 0; j < Y; j++)
        {
            chess[i][j] = 0;
        }
    }

    if (!TravelChessBoard(2, 0, 1))
    {
        printf("失败");
    }

    finish = clock();
    printf("本次耗时:%f秒\n", (double)(finish - start) / CLOCKS_PER_SEC);

    return 0;
}
```

### 最小生成树(Spanning Tree)

[最小生成树动画](https://www.bilibili.com/video/BV1Ve4y1h7aE/)

#### 普里姆(Prim)算法

##### 临界矩阵

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXWEIGHT 9999  //最大权值
#define MAXVERTEX 20    //最大顶点数
typedef char VetexType; //顶点类型
typedef int MatrixType; //矩阵类型

typedef struct AMGraph
{
    VetexType vertex[MAXVERTEX];
    MatrixType edge[MAXVERTEX][MAXVERTEX];
    int vertexes, edges; //顶点和边的个数
} AMGraph;

typedef struct Uset
{
    int adjvertex;
    int weight;
} Uset;

void CreatGraph(AMGraph *G)
{
    printf("Please input the number of vertices:\n");
    scanf("%d", &G->vertexes);
    printf("Please input the number of edges:\n");
    scanf("%d", &G->edges);
    printf("Please input the name of vertices\n");
    for (int i = 0; i < G->vertexes; i++)
    {
        scanf(" %c", &G->vertex[i]);
    }
    for (int i = 0; i < G->vertexes; i++)
    {
        for (int j = 0; j < G->vertexes; j++)
        {
            G->edge[i][j] = MAXWEIGHT;
        }
    }
    char v1, v2;
    int weight;
    printf("Please input the edge:\n");
    for (int i = 0; i < G->edges; i++)
    {
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c %d", &v1, &v2, &weight);
        for (int j = 0; j < G->vertexes; j++)
        {
            if (G->vertex[j] == v1)
            {
                index_v1 = j;
            }
            if (G->vertex[j] == v2)
            {
                index_v2 = j;
            }
            if (index_v1 != -1 && index_v2 != -1)
            {
                break;
            }
        }
        G->edge[index_v1][index_v2] = weight;
        G->edge[index_v2][index_v1] = weight; //有向则删去此行
    }
}

int Min_Uset(Uset *U, int n)
{
    int min = MAXWEIGHT;
    int pos = 0;

    for (int i = 0; i < n; i++)
    {
        if (U[i].weight != 0 && U[i].weight < min)
        {
            min = U[i].weight;
            pos = i;
        }
    }
    return pos;
}

void MST_Prim(AMGraph *G)
{
    int u = 0; //起点
    Uset *U = (Uset *)malloc(sizeof(Uset) * G->vertexes);

    //初始化操作
    for (int i = 0; i < G->vertexes; i++)
    {
        U[i].adjvertex = u;     //起始点
        U[i].weight = G->edge[u][i];
    }
    U[u].weight = 0; //表示u已经加入集合U

    for (int i = 1; i < G->vertexes; i++)
    {
        int min = Min_Uset(U, G->vertexes); //找到最小的权
        int u_0 = U[min].adjvertex;
        printf("%c->%c\t", G->vertex[u_0], G->vertex[min]);
        U[min].weight = 0;

        //跟新U集合
        for (int j = 0; j < G->vertexes; j++)
        {
            if (G->edge[min][j] < U[j].weight)
            {
                U[j].weight = G->edge[min][j];
                U[j].adjvertex = min;
            }
        }
    }

    free(U);
}

int main()
{
    AMGraph G;
    CreatGraph(&G);

    MST_Prim(&G);
    return 0;
}
```

##### 邻接表

```C
#include <stdio.h>
#include <stdlib.h>

#define MAXVERTEX 20
#define MAXWEIGHT 999

typedef char VertexType;
typedef struct EdgeNode
{ //边表结点
    int adjvertex;
    int weight;
    struct EdgeNode *next;
} EdgeNode;

typedef struct VertexNode
{ //顶点表
    VertexType vertex;
    EdgeNode *firstEdge;
} VertexNode;

typedef struct Graph
{
    VertexNode AdjList[MAXVERTEX];
    int numVertex, numEdges;
} GraphAdjList;

typedef struct Uset
{
    int adjvertex;
    int weight;
} Uset;

void CreatGraph(GraphAdjList *G)
{
    printf("Please input the number of vertexs:\n");
    scanf("%d", &G->numVertex);
    printf("Please input the number of Edges:\n");
    scanf("%d", &G->numEdges);

    printf("Please input the name of vertexs:\n");
    for (int i = 0; i < G->numVertex; i++)
    {
        scanf(" %c", &G->AdjList[i].vertex);
        G->AdjList[i].firstEdge = NULL;
    }

    char v1, v2;
    int weight;
    EdgeNode *e;
    printf("Please input the edges:\n");
    for (int i = 0; i < G->numEdges; i++)
    {
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c %d", &v1, &v2, &weight);
        for (int j = 0; j < G->numVertex; j++)
        {
            if (G->AdjList[j].vertex == v1)
            {
                index_v1 = j;
            }
            if (G->AdjList[j].vertex == v2)
            {
                index_v2 = j;
            }
            if (index_v1 != -1 && index_v2 != -1)
            {
                break;
            }
        }
        e = (EdgeNode *)malloc(sizeof(EdgeNode));
        e->adjvertex = index_v2;
        e->weight = weight;
        e->next = G->AdjList[index_v1].firstEdge;
        G->AdjList[index_v1].firstEdge = e;

        e = (EdgeNode *)malloc(sizeof(EdgeNode));
        e->adjvertex = index_v1;
        e->weight = weight;
        e->next = G->AdjList[index_v2].firstEdge;
        G->AdjList[index_v2].firstEdge = e;
    }
}

int Min_Uset(Uset *U, int n)
{
    int min = MAXVERTEX;
    int pos = 0;

    for (int i = 0; i < n; i++)
    {
        if (U[i].weight != 0 && U[i].weight < min)
        {
            min = U[i].weight;
            pos = i;
        }
    }
    return pos;
}

void MST_Prim(GraphAdjList *G)
{
    int u = 0;
    Uset *U = (Uset *)malloc(sizeof(Uset) * G->numVertex);

    for (int i = 0; i < G->numVertex; i++)
    {
        U[i].adjvertex = u;
        U[i].weight = MAXVERTEX;
    }
    U[u].weight = 0;

    EdgeNode *p = G->AdjList[u].firstEdge;
    while (p)
    {
        U[p->adjvertex].weight = p->weight;
        p = p->next;
    }

    for (int i = 1; i < G->numVertex; i++)
    {
        int min = Min_Uset(U, G->numVertex);
        int u_0 = U[min].adjvertex;
        printf("%c->%c", G->AdjList[u_0].vertex, G->AdjList[min].vertex);
        U[min].weight = 0;

        EdgeNode *p_min = G->AdjList[min].firstEdge;
        while (p_min)
        {
            if (p_min->weight < U[p_min->adjvertex].weight)
            {
                U[p_min->adjvertex].adjvertex = min;
                U[p_min->adjvertex].weight = p_min->weight;
            }
            p_min = p_min->next;
        }
    }
    free(U);
}

int main()
{
    GraphAdjList G;
    CreatGraph(&G);

    MST_Prim(&G);
    return 0;
}
```

#### 克鲁斯卡尔(Kruskal)算法

##### 邻接矩阵

```c
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

#define MAXWEIGHT 9999  //最大权值
#define MAXVERTEX 20    //最大顶点数
typedef char VetexType; //顶点类型
typedef int MatrixType; //矩阵类型

typedef struct Eset
{
    int start;
    int end;
    int weight;
} Eset;

typedef struct AMGraph
{
    VetexType vertex[MAXVERTEX];
    MatrixType edge[MAXVERTEX][MAXVERTEX];
    int vertexes, edges; //顶点和边的个数
} AMGraph;

void CreatGraph(AMGraph *G)
{
    printf("Please input the number of vertices:\n");
    scanf("%d", &G->vertexes);
    printf("Please input the number of edges:\n");
    scanf("%d", &G->edges);
    printf("Please input the name of vertices\n");
    for (int i = 0; i < G->vertexes; i++)
    {
        scanf(" %c", &G->vertex[i]);
    }
    for (int i = 0; i < G->vertexes; i++)
    {
        for (int j = 0; j < G->vertexes; j++)
        {
            G->edge[i][j] = MAXWEIGHT;
        }
    }
    char v1, v2;
    int weight;
    printf("Please input the edge:\n");
    for (int i = 0; i < G->edges; i++)
    {
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c %d", &v1, &v2, &weight);
        for (int j = 0; j < G->vertexes; j++)
        {
            if (G->vertex[j] == v1)
            {
                index_v1 = j;
            }
            if (G->vertex[j] == v2)
            {
                index_v2 = j;
            }
            if (index_v1 != -1 && index_v2 != -1)
            {
                break;
            }
        }
        G->edge[index_v1][index_v2] = weight;
        G->edge[index_v2][index_v1] = weight; //有向则删去此行
    }
}

//冒泡排序
void Sort_Eset(Eset *E, int length)
{
    bool flag = true;
    for (int i = 0; i < length - 1 && flag; i++)
    {
        flag = false;
        for (int j = 0; j < length - 1 - i; j++)
        {
            if (E[j].weight > E[j + 1].weight)
            {
                flag = true;
                Eset temp = E[j];
                E[j] = E[j + 1];
                E[j + 1] = temp;
            }
        }
    }
}

void InitEset(Eset *E, AMGraph *G)
{
    Eset *p = E;
    //遍历上三角矩阵
    for (int i = 0; i < G->vertexes; i++)
    {
        for (int k = i + 1; k < G->vertexes; k++)
        {
            if (G->edge[i][k] < MAXWEIGHT)
            {
                p->start = i;
                p->end = k;
                p->weight = G->edge[i][k];
                ++p;
            }
        }
    }
    p = NULL;
}

void MST_Krusal(AMGraph *G)
{
    Eset *E = (Eset *)malloc(sizeof(Eset) * G->edges);
    InitEset(E, G);
    Sort_Eset(E, G->edges);

    int V[G->vertexes]; // V集合存放连通依赖点
    for (int i = 0; i < G->vertexes; i++)
    {
        V[i] = i;
    }

    for (int j = 0; j < G->edges; j++)
    {
        int v1 = E[j].start;
        int v2 = E[j].end;

        int component_v1 = V[v1];
        int component_v2 = V[v2];
        if (component_v1 != component_v2) //不会形成环
        {
            printf("%c->%c ", G->vertex[v1], G->vertex[v2]);

            //更新依赖点，将v2依赖于v1,或将依赖于v2的改为依赖于v1
            for (int k = 0; k < G->vertexes; k++)
            {
                if (V[k] == component_v2)
                {
                    V[k] = component_v1;
                }
            }
        }
    }
    free(E);
}

int main()
{
    AMGraph G;
    CreatGraph(&G);

    MST_Krusal(&G);
    return 0;
}
```

##### 邻接表

```c
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

#define MAXVERTEX 20
#define MAXWEIGHT 999

typedef struct Eset
{
    int start;
    int end;
    int weight;
} Eset;

typedef char VertexType;
typedef struct EdgeNode
{ //边表结点
    int adjvertex;
    int weight;
    struct EdgeNode *next;
} EdgeNode;

typedef struct VertexNode
{ //顶点表
    VertexType vertex;
    EdgeNode *firstEdge;
} VertexNode;

typedef struct Graph
{
    VertexNode AdjList[MAXVERTEX];
    int numVertex, numEdges;
} GraphAdjList;

void CreatGraph(GraphAdjList *G)
{
    printf("Please input the number of vertexs:\n");
    scanf("%d", &G->numVertex);
    printf("Please input the number of Edges:\n");
    scanf("%d", &G->numEdges);

    printf("Please input the name of vertexs:\n");
    for (int i = 0; i < G->numVertex; i++)
    {
        scanf(" %c", &G->AdjList[i].vertex);
        G->AdjList[i].firstEdge = NULL;
    }

    char v1, v2;
    int weight;
    EdgeNode *e;
    printf("Please input the edges:\n");
    for (int i = 0; i < G->numEdges; i++)
    {
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c %d", &v1, &v2, &weight);
        for (int j = 0; j < G->numVertex; j++)
        {
            if (G->AdjList[j].vertex == v1)
            {
                index_v1 = j;
            }
            if (G->AdjList[j].vertex == v2)
            {
                index_v2 = j;
            }
            if (index_v1 != -1 && index_v2 != -1)
            {
                break;
            }
        }
        e = (EdgeNode *)malloc(sizeof(EdgeNode));
        e->adjvertex = index_v2;
        e->weight = weight;
        e->next = G->AdjList[index_v1].firstEdge;
        G->AdjList[index_v1].firstEdge = e;
    }
}

//冒泡排序
void Sort_Eset(Eset *E, int length)
{
    bool flag = true;
    for (int i = 0; i < length - 1 && flag; i++)
    {
        flag = false;
        for (int j = 0; j < length - 1 - i; j++)
        {
            if (E[j].weight > E[j + 1].weight)
            {
                flag = true;
                Eset temp = E[j];
                E[j] = E[j + 1];
                E[j + 1] = temp;
            }
        }
    }
}

void InitEset(Eset *E, GraphAdjList *G)
{
    Eset *p_E = E;

    for (int i = 0; i < G->numVertex; i++)
    {
        EdgeNode *p = G->AdjList[i].firstEdge;
        while (p)
        {
            p_E->start = i;
            p_E->end = p->adjvertex;
            p_E->weight = p->weight;

            p = p->next;
            p_E++;
        }
    }
    p_E = NULL;
}

void MST_Krusal(GraphAdjList *G)
{
    Eset *E = (Eset *)malloc(sizeof(Eset) * G->numEdges);
    InitEset(E, G);
    Sort_Eset(E, G->numEdges);

    int V[G->numVertex];
    for (int i = 0; i < G->numVertex; i++)
    {
        V[i] = i;
    }

    for (int j = 0; j < G->numEdges; j++)
    {
        int v1 = E[j].start;
        int v2 = E[j].end;

        int component_v1 = V[v1];
        int component_v2 = V[v2];

        if (component_v1 != component_v2)
        {
            printf("%c->%c ", G->AdjList[v1].vertex, G->AdjList[v2].vertex);

            for (int k = 0; k < G->numVertex; k++)
            {
                if (component_v2 == V[k])
                {
                    V[k] = component_v1;
                }
            }
        }
    }
    free(E);
}

int main()
{
    GraphAdjList G;
    CreatGraph(&G);

    MST_Krusal(&G);
    return 0;
}
```

### 拓扑排序

DAG图：一个无环的有向图称作有向无环图

#### AOC-网

+ AOC-网：用一个有向图表示一个工程的各个子工程及其相互制约关系，其中顶点表示活动，弧表示优先制约关系  

+ 拓扑排序：就是将AOV-网中所有顶点排成一个线性序列，该序列满足：若在AOV-网中由
  顶点v~i~到顶点v~j~有一条路径，则在该线性序列中的顶点v~i~必定在顶点v~j~之前  

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209171444186.png" alt="image-20220917144447013" style="zoom:67%;" />

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209171447337.png" alt="image-20220917144733353" style="zoom:67%;" />

#### 代码实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAXVERTEX 20
#define MAXWEIGHT 999
#define MAXSTACK 100
#define ERROR 0
#define OK 1

typedef int Status;

typedef int ElemType;
typedef struct SqStack
{
    ElemType *base;
    ElemType *top;
    int stacksize;
} SqStack;

Status InitStack(SqStack *S)
{
    S->base = (ElemType *)malloc(sizeof(ElemType) * MAXSTACK);
    if (!(S->base))
        return ERROR;
    S->top = S->base;
    S->stacksize = MAXSTACK;
    return OK;
}

Status Push(SqStack *S, ElemType e)
{
    if (S->top - S->base == S->stacksize)
        return ERROR;
    *(S->top++) = e;
    return OK;
}

Status Pop(SqStack *S, ElemType *e)
{
    if (S->base == S->top)
        return ERROR;
    *e = *(--(S->top));
    return OK;
}

typedef char VertexType;
typedef struct EdgeNode
{ //边表结点
    int adjvertex;
    struct EdgeNode *next;
} EdgeNode;

typedef struct VertexNode
{ //顶点表
    VertexType vertex;
    EdgeNode *firstEdge;
} VertexNode;

typedef struct Graph
{
    VertexNode AdjList[MAXVERTEX];
    int numVertex, numEdges;
} GraphAdjList;

void CreatGraph(GraphAdjList *G)
{
    printf("Please input the number of vertexs:\n");
    scanf("%d", &G->numVertex);
    printf("Please input the number of Edges:\n");
    scanf("%d", &G->numEdges);

    printf("Please input the name of vertexs:\n");
    for (int i = 0; i < G->numVertex; i++)
    {
        scanf(" %c", &G->AdjList[i].vertex);
        G->AdjList[i].firstEdge = NULL;
    }

    char v1, v2;
    EdgeNode *e;
    printf("Please input the edges:\n");
    for (int i = 0; i < G->numEdges; i++)
    {
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c", &v1, &v2);
        for (int j = 0; j < G->numVertex; j++)
        {
            if (G->AdjList[j].vertex == v1)
            {
                index_v1 = j;
            }
            if (G->AdjList[j].vertex == v2)
            {
                index_v2 = j;
            }
            if (index_v1 != -1 && index_v2 != -1)
            {
                break;
            }
        }
        e = (EdgeNode *)malloc(sizeof(EdgeNode));
        e->adjvertex = index_v2;
        e->next = G->AdjList[index_v1].firstEdge;
        G->AdjList[index_v1].firstEdge = e;
    }
}

//获取所有点的indegree
void InDegree(GraphAdjList *G, int *a)
{
    for (int i = 0; i < G->numVertex; i++)
    {
        EdgeNode *p = G->AdjList[i].firstEdge;
        while (p)
        {
            a[p->adjvertex]++;
            p = p->next;
        }
    }
}

int *Get_Topo(GraphAdjList *G)
{
    int *indegree = (int *)malloc(sizeof(int) * G->numVertex);
    memset(indegree, 0, sizeof(int) * G->numVertex);
    int *topo = (int *)malloc(sizeof(int) * G->numVertex);
    memset(topo, 0, sizeof(int) * G->numVertex);

    InDegree(G, indegree);

    SqStack S;
    InitStack(&S);

    for (int i = 0; i < G->numVertex; i++)
    {
        if (!indegree[i]) //如果indegree = 0,入栈
            Push(&S, i);
    }

    int m = 0;
    int pop;
    while (S.top != S.base)
    {
        Pop(&S, &pop);
        topo[m++] = pop;
        EdgeNode *p = G->AdjList[pop].firstEdge;

        while (p)
        {
            --indegree[p->adjvertex];

            if (!indegree[p->adjvertex])
            {
                Push(&S, p->adjvertex);
            }
            p = p->next;
        }
    }

    if (m < G->numVertex)
    {
        //如果m = G->numVertex 说明G为AOV,否则说明有回路
        free(indegree);
        free(topo);
        return NULL;
    }
    else
    {
        free(indegree);
        return topo;
    }
}

int TopoSort(GraphAdjList *G)
{
    int *topo = Get_Topo(G);
    if (!topo)
    {
        printf("The Graph is not AVO!\n");
        return 0;
    }
    for (int i = 0; i < G->numVertex; i++)
    {
        printf("%c ", G->AdjList[topo[i]].vertex);
    }
    free(topo);
    topo = NULL;
}

int main()
{
    GraphAdjList G;
    CreatGraph(&G);

    TopoSort(&G);
    return 0;
}
```

### 关键路径

#### AOE-网

+ AOE网：弧表示活动，以顶点表示活动开始或结束事件

+ 关键路径：一条从源点(v~0~)到汇点(V~8~)的带权路径长度最长的路径

+ ve(i)：表示事件i的最早发生时间

+ vl(i)：表示事件i的最迟发生时间

+ e(i)：表示活动ai的最早发生时间

+ l(i)：表示活动ai的最晚发生时间

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209172127234.png" alt="image-20220917212729588" style="zoom:67%;" />

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209172128971.png" alt="image-20220917212802083" style="zoom:67%;" />



#### 代码实现

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAXVERTEX 20
#define MAXWEIGHT 999
#define MAXSTACK 100
#define ERROR 0
#define OK 1

typedef int Status;

typedef int ElemType;
typedef struct SqStack
{
    ElemType *base;
    ElemType *top;
    int stacksize;
} SqStack;

Status InitStack(SqStack *S)
{
    S->base = (ElemType *)malloc(sizeof(ElemType) * MAXSTACK);
    if (!(S->base))
        return ERROR;
    S->top = S->base;
    S->stacksize = MAXSTACK;
    return OK;
}

Status Push(SqStack *S, ElemType e)
{
    if (S->top - S->base == S->stacksize)
        return ERROR;
    *(S->top++) = e;
    return OK;
}

Status Pop(SqStack *S, ElemType *e)
{
    if (S->base == S->top)
        return ERROR;
    *e = *(--(S->top));
    return OK;
}

typedef char VertexType;
typedef struct EdgeNode
{ //边表结点
    int adjvertex;
    int weight;
    struct EdgeNode *next;
} EdgeNode;

typedef struct VertexNode
{ //顶点表
    VertexType vertex;

    EdgeNode *firstEdge;
} VertexNode;

typedef struct Graph
{
    VertexNode AdjList[MAXVERTEX];
    int numVertex, numEdges;
} GraphAdjList;

void CreatGraph(GraphAdjList *G)
{
    printf("Please input the number of vertexs:\n");
    scanf("%d", &G->numVertex);
    printf("Please input the number of Edges:\n");
    scanf("%d", &G->numEdges);

    printf("Please input the name of vertexs:\n");
    for (int i = 0; i < G->numVertex; i++)
    {
        scanf(" %c", &G->AdjList[i].vertex);
        G->AdjList[i].firstEdge = NULL;
    }

    char v1, v2;
    EdgeNode *e;
    int weight;
    printf("Please input the edges:\n");
    for (int i = 0; i < G->numEdges; i++)
    {
        int index_v1 = -1, index_v2 = -1;
        scanf(" %c %c %d", &v1, &v2, &weight);
        for (int j = 0; j < G->numVertex; j++)
        {
            if (G->AdjList[j].vertex == v1)
            {
                index_v1 = j;
            }
            if (G->AdjList[j].vertex == v2)
            {
                index_v2 = j;
            }
            if (index_v1 != -1 && index_v2 != -1)
            {
                break;
            }
        }
        e = (EdgeNode *)malloc(sizeof(EdgeNode));
        e->adjvertex = index_v2;
        e->weight = weight;
        e->next = G->AdjList[index_v1].firstEdge;
        G->AdjList[index_v1].firstEdge = e;
    }
}

//获取所有点的indegree
void InDegree(GraphAdjList *G, int *a)
{
    for (int i = 0; i < G->numVertex; i++)
    {
        EdgeNode *p = G->AdjList[i].firstEdge;
        while (p)
        {
            a[p->adjvertex]++;
            p = p->next;
        }
    }
}

int *Get_Topo(GraphAdjList *G)
{
    int *indegree = (int *)malloc(sizeof(int) * G->numVertex);
    memset(indegree, 0, sizeof(int) * G->numVertex);
    int *topo = (int *)malloc(sizeof(int) * G->numVertex);
    memset(topo, 0, sizeof(int) * G->numVertex);

    InDegree(G, indegree);

    SqStack S;
    InitStack(&S);

    for (int i = 0; i < G->numVertex; i++)
    {
        if (!indegree[i]) //如果indegree = 0,入栈
            Push(&S, i);
    }

    int m = 0;
    int pop;
    while (S.top != S.base)
    {
        Pop(&S, &pop);
        topo[m++] = pop;
        EdgeNode *p = G->AdjList[pop].firstEdge;

        while (p)
        {
            --indegree[p->adjvertex];

            if (!indegree[p->adjvertex])
            {
                Push(&S, p->adjvertex);
            }
            p = p->next;
        }
    }

    if (m < G->numVertex)
    {
        //如果m = G->numVertex 说明G为AOV,否则说明有回路
        free(indegree);
        free(topo);
        return NULL;
    }
    else
    {
        free(indegree);
        return topo;
    }
}

void CriticalPath(GraphAdjList *G)
{
    int *topo = Get_Topo(G);
    if (!topo)
    {
        printf("The Graph is not AVO!\n");
        return;
    }

    int n = G->numVertex;
    int ve[n], vl[n]; // ve表示事件i的最早发生时间，vl表示最晚发生时间
    memset(ve, 0, sizeof(int) * n);

    for (int i = 0; i < n; i++)
    {
        int k = topo[i];
        EdgeNode *p = G->AdjList[k].firstEdge;
        while (p)
        {
            if (ve[p->adjvertex] < ve[k] + p->weight)
            {
                ve[p->adjvertex] = ve[k] + p->weight;
            }
            p = p->next;
        }
    }

    //把所有顶点的最晚发生时间初始化为汇点的最晚发生时间
    for (int i = 0; i < n; i++)
    {
        vl[i] = ve[topo[n - 1]];
    }

    for (int i = n - 1; i >= 0; --i)
    {
        int k = topo[i];
        EdgeNode *p = G->AdjList[k].firstEdge;

        while (p)
        {
            if (vl[k] > vl[p->adjvertex] - p->weight)
            {
                vl[k] = vl[p->adjvertex] - p->weight;
            }
            p = p->next;
        }
    }

    for (int i = 0; i < n; i++)
    {
        EdgeNode *p = G->AdjList[i].firstEdge;
        while (p)
        {
            int j = p->adjvertex;
            int e = ve[i];
            int l = vl[j] - p->weight;

            if (e == l)
            { //为关键路径
                printf("%c->%c ", G->AdjList[i].vertex, G->AdjList[j].vertex);
            }
            p = p->next;
        }
    }
    free(topo);
}

int main()
{
    GraphAdjList G;
    CreatGraph(&G);
    CriticalPath(&G);
    return 0;
}
```

## **查找**

### 基本概念

+ 查找表：由同一类型的数据元素构成的集合
+ 静态查找表和动态查找表：在查找的同时进行对表做修改操作(如插入和删除),为动态查找表，否则为静态查找表
+ 平均查找长度(ASL)：对于n个记录的表，查找成功的平均长度为：(P~i~为查找表中第i个记录的概率,C~i~为找到时已比较的个数)  $ASL=sum_{i=1}^N P~i~ C~i~$

### 线性表的查找

#### 顺序查找

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    // array[0]闲置不用
    int array[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8};

    int key = 5;
    //第一种方法
    // for (int i = sizeof(array)/array[0]; i > 0; i--)
    // {
    //     if (array[i] == key)
    //     {
    //         printf("%d", i);
    //         break;
    //     }
    // }

    //改进 array[0] 置为key, 免去查找过程判断表是否检查完毕
    array[0] = key;
    int i;
    for (i = sizeof(array)/array[0]; array[i] != key; --i)
        ;

    printf("%d", i);
    system("pause");
    return 0;
}
```

#### 折半查找(有序表)

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int array[11] = {5, 16, 20, 27, 30, 36, 44, 55, 60, 67};

    int key = 20;
    int low = 0, high = sizeof(array) / array[0], mid = 0;
    while (low <= high)
    {
        mid = (low + high) / 2;
        if (key == array[mid])
        {
            printf("%d ", mid);
            break;
        }
        else if (key < array[mid])
            high = mid - 1;
        else
            low = mid + 1;
    }

    system("pause");
    return 0;
}
```

#### 分块查找

又称索引顺序查找，需要建立一个索引表，存储该块的起始位置和最大关键字

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209181615039.png" alt="image-20220918161537876" style="zoom:67%;" />

### 二叉顺序树(Binary Sort Tree)

#### 二叉顺序树的定义

二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

1. 若它的左子树不空，则左子树上所有结点的值均小千它的根结点的值；

2. 若它的右子树不空，则右子树上所有结点的值均大千它的根结点的值；

3. 它的左、 右子树也分别为二叉排序树。 

4. 由定义可以得出二叉排序树的一个重要性质：中序遍历一棵二叉树时可以得到一个结点值递增的有序序列。

   <img src="https://gitee.com/newcwc/picture/raw/master/image/202209182322128.png" alt="image-20220918232234834" style="zoom:67%;" />

#### 二叉树的查找、删除、插入

+ 查找：

1. 若二叉排序树为空， 则查找失败，返回空指针。
2. 若二叉排序树非空， 将给定值key与根结点的关键字T->data.key进行比较：
   • 若key等千T->data.key, 则查找成功，返回根结点地址；
   • 若key小 千T->data.key, 则递归查找左子树；
   • 若key大千T->data.key, 则递归查找右子树 

+ 插入：

1. 若二叉排序树为空，则待插入结点\*S 作为根结点插入到空树中。
2. 若二叉排序树非空，则将key与根结点的关键字T->data.key进行比较：
   • 若key小于T->data.key, 则将\*S 插入左子树；
   • 若key大于T->data.key, 则将\*S 插入右子树  

+ 删除：

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209182329521.png" alt="image-20220918232944958" style="zoom: 50%;" />

#### 代码实现

```c
#include <stdio.h>
#include <stdlib.h>

#define FALSE 0
#define TRUE 1

typedef int Status;
// 二叉树的二叉链表结点结构定义
typedef struct BiTNode
{
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// f为了查找不成功时,令p赋值为search的最后一个位置
// p在insert会用到,查找成功时p为关键词的结点
Status SearchBST(BiTree T, int key, BiTree f, BiTree *p)
{
    if (!T) // 查找不成功
    {
        *p = f;
        return FALSE;
    }
    else if (key == T->data) // 查找成功
    {
        *p = T;
        return TRUE;
    }
    else if (key < T->data)
    {
        return SearchBST(T->lchild, key, T, p); // 在左子树继续查找
    }
    else
    {
        return SearchBST(T->rchild, key, T, p); // 在右子树继续查找
    }
    return TRUE;
}

Status InsertBST(BiTree *T, int key)
{
    BiTree p, s;
    //假如查找不到
    if (!SearchBST(*T, key, NULL, &p))
    {
        s = (BiTree)malloc(sizeof(BiTNode));
        s->data = key;
        s->lchild = s->rchild = NULL;

        if (!p) //为空树
        {
            *T = s; // 插入 s 为新的根结点
        }
        else if (key < p->data)
        {
            p->lchild = s; // 插入 s 为左孩子
        }
        else
        {
            p->rchild = s; // 插入 s 为右孩子
        }
        return TRUE;
    }
    else
    {
        return FALSE; // 树中已有关键字相同的结点，不再插入
    }
}

Status Delete(BiTree *p)
{
    BiTree q, s;

    if ((*p)->rchild == NULL)   
    {
        q = *p;
        *p = (*p)->lchild;
        free(q);
    }
    else if ((*p)->lchild == NULL)
    {
        q = *p;
        *p = (*p)->rchild;
        free(q);
    }
    else
    {
        q = *p;
        s = (*p)->lchild;

        while (s->rchild)
        {
            q = s;
            s = s->rchild;
        }

        (*p)->data = s->data;

        if (q != *p)
        {
            q->rchild = s->lchild;
        }
        else
        {
            q->lchild = s->lchild;
        }

        free(s);
    }
    return TRUE;
}

Status DeleteBST(BiTree *T, int key)
{
    BiTree p = NULL;
    //假如查找不到
    if (!SearchBST(*T, key, NULL, &p))
    {
        return FALSE;
    }
    else
    {
        Delete(&p);
        return TRUE;
    }
}

//中序遍历
void InOrder(BiTree T)
{
    if (T)
    {
        InOrder(T->lchild);
        printf("%d ", T->data);
        InOrder(T->rchild);
    }
}

int main()
{
    BiTree T = NULL;
    BiTree p;

    int array[10] = {70, 105, 115, 104, 67, 46, 99, 111, 109};

    for (int i = 0; i < 9; i++)
    {
        InsertBST(&T, array[i]);
    }
    InOrder(T);
    printf("\n");

    SearchBST(T, 105, NULL, &p);

    DeleteBST(&T, 105);
    InOrder(T);
    printf("\n");

    system("pause");
    return 0;
}
```

### 平衡二叉树(AVL树)

#### 定义

平衡二叉树或者是空树，或者是具有如下特征的二叉排序树：

1. 左子树和右子树的深度之差的绝对值不超过1;
2. 左子树和右子树也是平衡二叉树。

若将二叉树上结点的平衡因子(Balance Factor,BF)定义为该结点左子树和右子树的深度之
差，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。  

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209182333993.png" alt="image-20220918233310507" style="zoom: 67%;" />

#### 代码实现(删除未完善)

```c
#include <iostream>
#include <math.h>
using namespace std;

struct node
{
    int data;
    int height;
    node *left, *right;
};

int getHeight(node *root)
{
    if (root == NULL)
    {
        return 0;
    }
    return root->height;
}

node *rotateLeft(node *root)
{
    node *temp = root->right;
    root->right = temp->left;
    temp->left = root;
    //更新高度
    root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
    temp->height = max(getHeight(temp->left), getHeight(temp->right)) + 1;

    return temp;
}

node *rotateRight(node *root)
{
    node *temp = root->left;
    root->left = temp->right;
    temp->right = root;

    root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
    temp->height = max(getHeight(temp->left), getHeight(temp->right)) + 1;
    return temp;
}

node *rotateLeftRight(node *root)
{
    root->left = rotateLeft(root->left);
    return rotateRight(root);
}

node *rotateRightLeft(node *root)
{
    root->right = rotateRight(root->right);
    return rotateLeftRight(root);
}

node *insert(node *root, int data)
{
    if (root == NULL)
    {
        root = new node();
        root->data = data;
        root->height = 1;
        root->left = NULL;
        root->right = NULL;
    }
    else if (data < root->data)
    {
        root->left = insert(root->left, data);
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
        if (getHeight(root->left) - getHeight(root->right) == 2)
        {
            if (data < root->left->data) // LL型 右旋
            {
                root = rotateRight(root);
            }
            else
            {
                root = rotateLeftRight(root); // LR型 先左旋再右旋
            }
        }
    }
    else
    {
        root->right = insert(root->right, data);
        root->height = max(getHeight(root->left), getHeight(root->right)) + 1;

        if (getHeight(root->left) - getHeight(root->right) == 2)
        {
            if (data < root->left->data) // RR型 左旋
            {
                root = rotateLeft(root);
            }
            else
            {
                root = rotateRightLeft(root); // RL型 先右旋再左旋
            }
        }
    }
    return root;
}

// f为了查找不成功时,令p赋值为search的最后一个位置
// p在insert会用到,查找成功时p为关键词的结点
int SearchBST(node *T, int key, node *f, node **p)
{
    if (!T) // 查找不成功
    {
        *p = f;
        return 0;
    }
    else if (key == T->data) // 查找成功
    {
        *p = T;
        return 1;
    }
    else if (key < T->data)
    {
        return SearchBST(T->left, key, T, p); // 在左子树继续查找
    }
    else
    {
        return SearchBST(T->right, key, T, p); // 在右子树继续查找
    }
    return 1;
}

int Delete(node *p)
{
    node *q, *s;

    if (p->right == NULL)
    {
        q = p;
        p = p->left;
        free(q);
    }
    else if (p->left == NULL)
    {
        q = p;
        p = p->right;
        free(q);
    }
    else
    {
        q = p;
        s = p->left;

        while (s->right)
        {
            q = s;
            s = s->right;
        }

        p->data = s->data;

        if (q != p)
        {
            q->right = s->left;
        }
        else
        {
            q->left = s->left;
        }

        free(s);
    }
    return 1;
}

int DeleteBST(node *T, int key)
{
    node *p = NULL;
    //假如查找不到
    if (!SearchBST(T, key, NULL, &p))
    {
        return 0;
    }
    else
    {
        Delete(p);
        return 1;
    }
}

//中序遍历
void InOrder(node *T)
{
    if (T)
    {
        InOrder(T->left);
        printf("%d ", T->data);
        InOrder(T->right);
    }
}

int main()
{
    node *root = NULL, *p;

    int array[10] = {70, 105, 115, 104, 67, 46, 99, 111, 109};

    for (int i = 0; i < 9; i++)
    {
        root = insert(root, array[i]);
    }

    InOrder(root);
    printf("\n");

    SearchBST(root, 105, NULL, &p);

    DeleteBST(root, 70);
    InOrder(root);
    printf("\n");

    system("pause");
    return 0;
}
```

### 哈希表(散列表)

#### 基本概念

+ 散列函数和散列地址:在记录的存储位置p和其关键字key之间建立一个确定的对应关
  系H,使 p=H(key), 称这个对应关系H为散列函数，p为散列地址.
+ 散列表：一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据
  记录。通常散列表的存储空间是一个一维数组，散列地址是数组的下标。 
+ 冲突和同义词：对不同的关键字可能得到同一散列地址，即key!=key2,而H(key1)=H(key2)
  这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，key1和key2称为同义词

#### 散列函数构造方法

+ 数字分析法
+ 平方取中法
+ 折叠法
+ ==除数取余法==
  + H(key) = key % p  

#### 处理冲突的方法

+ 开放地址法:H~i~= ( H(key) + d~i~) % m , i = 1, 2, …，k(k<=m-l)  
  + 线性探测法	d~i~ = 1,2,3, … ,m-1  
  + 二次探测法    d~i~ =1^2^,-1^2^,2^2^,-2^2^,3^2^...+k^2^,-k^2^(k<=m/2)  
  + 伪随机探测法  
+ 链地址法

#### 查找代码实现(除数取余法+线性探测法)

```c
#include <iostream>
using namespace std;

#define NULLKEY -999
#define HASHSIZE 16
#define MOD 13
typedef struct
{
    int *elem;
    int count;
} HashTable;

int InitHashTable(HashTable *H)
{
    H->count = HASHSIZE;
    H->elem = new int[HASHSIZE];
    for (int i = 0; i < HASHSIZE; i++)
    {
        H->elem[i] = NULLKEY;
    }
    return 1;
}

int Hash(int key)
{
    return key % MOD;
}

void InsertHash(HashTable *H, int key)
{
    int addr;
    addr = Hash(key);
    while (H->elem[addr] != NULLKEY)
    {
        addr = (addr + 1) % MOD;
    }
    H->elem[addr] = key;
}

int SearchHash(HashTable *H, int key, int *addr)
{
    *addr = Hash(key);
    while (H->elem[*addr] != key)
    {
        *addr = (*addr + 1) % MOD;
        if (H->elem[*addr] == NULLKEY || *addr == Hash(key))
        {
            return 0;
        }
    }
    return 1;
}

int main()
{
    HashTable H;
    InitHashTable(&H);

    int arr[] = {19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 70, 79};

    for (int i = 0; i < 12; i++)
    {
        InsertHash(&H, arr[i]);
    }

    int addr;
    if (SearchHash(&H, 84, &addr))
        cout << "the key is on the " << addr << " position" << endl;
    else
        cout << "can't search the key" << endl;
}
```

## 排序

### 直接插入排序

```c
#include <stdio.h>

void InsertSort(int k[], int n)
{
    int i, j, temp;

    for (int i = 1; i < n; i++)
    {
        if (k[i] < k[i - 1])
        {
            temp = k[i];
            for (j = i - 1; k[j] > temp; j--)
            {
                k[j + 1] = k[j];
            }
            k[j + 1] = temp;
        }
    }
}

int main()
{
    int i, a[10] = {5, 6, 0, 8, 3, 5, 6, 4, 2, 8};
  
    InsertSort(a, 10);
    for (int i = 0; i < 10; i++)
    {
        printf("%d", a[i]);
    }
    printf("\n");
}
```

### 折半插入排序

```c
#include <stdio.h>

void BInsertSort(int k[], int n)
{
    int i, j, temp;
    int low, high, mid;
    for (i = 1; i <= n; i++)
    {
        temp = k[i];
        low = 0, high = i - 1;
        while (low <= high)
        {
            mid = (low + high) / 2;
            if (temp < k[mid])
                high = mid - 1;
            else
                low = mid + 1;
        }
        for (j = i - 1; j >= high + 1; --j)
        {
            k[j + 1] = k[j];
        }
        k[high + 1] = temp;
    }
}

int main()
{
    int i, a[10] = {5, 6, 0, 8, 3, 5, 6, 4, 2, 8};

    BInsertSort(a, 10);
    for (int i = 0; i < 10; i++)
    {
        printf("%d", a[i]);
    }
    printf("\n");
}
```

### 希尔排序

```c
#include <iostream>
using namespace std;

void ShellInsert(int *L, int dk)
{
    int temp;
    int j = 0;
    for (int i = dk; i < 10; i++)
    {
        if (L[i] < L[i - dk])
        {
            temp = L[i];
            for (j = i - dk; j >= 0 && L[j] > temp; j -= dk)
                L[j + dk] = L[j];
            L[j + dk] = temp;
        }
    }
}

void ShellSort(int *L, int dt[], int t)
{
    for (int k = 0; k < t; k++)
    {
        ShellInsert(L, dt[k]);
    }
}

int main()
{

    int array[11] = {49, 38, 65, 97, 76, 13, 27, 49, 55, 4};
    int dt[] = {5, 3, 1};
    ShellSort(array, dt, 3);

    for (int i = 0; i < 10; i++)
    {
        cout << array[i] << " ";
    }
    return 0;
}
```

### 交换排序

#### 冒泡排序

```c
#include <iostream>
using namespace std;

void bubble_sort(int *L, int n)
{
    int temp, flag = 0;
    for (int i = 0; i < n; i++)
    {
        flag = 0;
        for (int j = 0; j < n - i - 1; j++)
        {
            if (L[j] > L[j + 1])
            {
                temp = L[j];
                L[j] = L[j + 1];
                L[j + 1] = temp;
                flag = 1;
            }
        }
        if (flag == 0)
            break;
    }
}

int main()
{
    int array[11] = {49, 38, 65, 97, 76, 13, 27, 49, 55, 4};
    bubble_sort(array, 10);

    for (int i = 0; i < 10; i++)
    {
        cout << array[i] << " ";
    }
    return 0;
}
```

#### 快速排序

```c
#include <iostream>
using namespace std;

int Partition(int *L, int low, int high)
{
    L[0] = L[low];
    int pivotloc = L[low];

    while (low < high)
    {
        while (low < high && L[high] >= pivotloc)
            high--; //找到比中心点小的元素
        L[low] = L[high];
        while (low < high && L[low] <= pivotloc)
            low++; //找到比中心点大的元素
        L[high] = L[low];
    }
    L[low] = L[0];

    return low;
}

void Qsort(int *L, int low, int high)
{
    if (low < high)
    {
        int pivotloc = Partition(L, low, high); //找中心点位置

        Qsort(L, low, pivotloc - 1);
        Qsort(L, pivotloc + 1, high);
    }
}

int main()
{
    int array[11] = {0, 38, 65, 97, 76, 13, 27, 49, 55, 4}; //第一个位置为空
    Qsort(array, 1, 9);

    for (int i = 1; i < 10; i++)
    {
        cout << array[i] << " ";
    }
    return 0;
}
```

### 选择排序

#### 简单选择排序

```c
#include <iostream>
using namespace std;

void SelectSort(int *L, int n)
{
    for (int i = 0; i < n; i++)
    {
        int min = i;
        for (int j = i + 1; j < n; j++)
        {
            if (L[j] < L[min])
                min = j;
        }
        if (min != i)
        {
            int temp = L[min];
            L[min] = L[i];
            L[i] = temp;
        }
    }
}

int main()
{
    int array[11] = {0, 38, 65, 97, 76, 13, 27, 49, 55, 4};
    SelectSort(array, 10);

    for (int i = 1; i < 10; i++)
    {
        cout << array[i] << " ";
    }
    return 0;
}
```

#### 堆排序

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209281736926.png" alt="image-20220928173631283" style="zoom:50%;" />

<img src="https://gitee.com/newcwc/picture/raw/master/image/202209281736154.png" style="zoom:50%;" />

```c
#include <iostream>
using namespace std;

void Print(int n, int *a)
{
    cout << n << ' ' << a[1];
    for (int i = 2; i <= n; i++)
        cout << " " << a[i];
    cout << endl;
}

void HeapSort(int i, int n, int *a)
{
    int j = 2 * i;
    while (j <= n)
    {
        if (j < n && a[j] > a[j + 1])
            j++;
        if (a[i] > a[j])
        {
            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
        i = j;
        j = 2 * i;
    }
}

int main()
{
    int n;
    cin >> n;
    int a[1000];
    for (int i = 1; i <= n; i++)
        cin >> a[i];

    for (int i = n / 2; i >= 1; i--)
        HeapSort(i, n, a);
    Print(n, a);

    for (int i = 0; i < n - 1; i++)
    {
        int temp = a[1];
        a[1] = a[n - i];
        a[n - i] = temp;
        HeapSort(1, n - i - 1, a);
        Print(n, a);
    }

    return 0;
}
```

归并排序

```c
#include <iostream>
#include <string>
using namespace std;

int n;

void Merge(string *str, string *ans, int left, int right, int d)
{
    int i = left, j = right, k = left;
    for (; i < left + d && j < right + d && j <= n; k++)
    {
        if (str[i] > str[j])
            ans[k] = str[i++];
        else
            ans[k] = str[j++];
    }
    while (i < left + d)
        ans[k++] = str[i++];
    while (j < right + d && j <= n)
        ans[k++] = str[j++];

    for (int i = 1; i <= n; i++)
        str[i] = ans[i];
}

void Print(string *ans)
{
    for (int i = 1; i <= n; i++)
    {
        if (i != n)
            cout << ans[i] << " ";
        else
            cout << ans[i] << endl;
    }
}

void MSort(string *str, string *ans)
{
    int d = 1, num = n;
    while (num > 1)
    {
        int i = 1, j = d + 1;
        while (j <= n)
        {
            Merge(str, ans, i, j, d);
            num--;
            i += d * 2;
            j += d * 2;
        }
        d = d * 2;
        Print(ans);
    }
}

int main()
{
    int t;
    cin >> t;

    while (t--)
    {
        cin >> n;
        string str[1000];
        string ans[1000];
        for (int i = 1; i <= n; i++)
        {
            cin >> str[i];
            ans[i] = str[i];
        }

        MSort(str, ans);
        cout << endl;
    }

    return 0;
}
```

